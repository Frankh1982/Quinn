diff --git a/runtime/green/server.py b/runtime/green/server.py
--- a/runtime/green/server.py
+++ b/runtime/green/server.py
@@ -3371,6 +3371,204 @@
 # HTTP handlers
 # =============================================================================
 
+# =============================================================================
+# Manifest + simple classification HTTP API
+# =============================================================================
+
+async def handle_get_manifest(request: web.Request) -> web.Response:
+    """
+    GET /manifest?project=<name>
+
+    Returns the current project manifest JSON.
+    """
+    project_param = (request.rel_url.query.get("project") or "").strip()
+    project_name = safe_project_name(project_param) if project_param else DEFAULT_PROJECT_NAME
+    ensure_project(project_name)  # ensure directory structure exists
+    manifest = load_manifest(project_name)
+    resp = web.json_response({"ok": True, "project": project_name, "manifest": manifest})
+    resp.headers["Access-Control-Allow-Origin"] = "*"
+    return resp
+
+async def handle_update_manifest(request: web.Request) -> web.Response:
+    """
+    POST /manifest
+    JSON body:
+      {
+        "project": "myproj" (optional, default = default),
+        "patch": { ... }    (optional shallow merge into existing manifest),
+        "manifest": { ... } (optional full manifest replacement)
+      }
+
+    If "manifest" is provided and is a dict, it replaces the existing manifest
+    (with minimal safety defaults reapplied).
+    If only "patch" is provided, it is shallow-merged into the existing manifest.
+    Returns the updated manifest.
+    """
+    try:
+        payload = await request.json()
+    except Exception:
+        resp = web.json_response({"ok": False, "error": "Expected JSON body."}, status=400)
+        resp.headers["Access-Control-Allow-Origin"] = "*"
+        return resp
+
+    project_param = (payload.get("project") or "").strip() if isinstance(payload, dict) else ""
+    project_name = safe_project_name(project_param) if project_param else DEFAULT_PROJECT_NAME
+    ensure_project(project_name)
+
+    current = load_manifest(project_name)
+
+    full_manifest = payload.get("manifest") if isinstance(payload, dict) else None
+    patch = payload.get("patch") if isinstance(payload, dict) else None
+
+    if isinstance(full_manifest, dict):
+        # replace, but keep required keys sane
+        new_m = dict(full_manifest)
+        new_m.setdefault("version", MANIFEST_VERSION)
+        new_m.setdefault("project_name", safe_project_name(project_name))
+        new_m.setdefault("created_at", current.get("created_at", time.time()))
+        new_m.setdefault("updated_at", time.time())
+        new_m.setdefault("goal", current.get("goal", ""))
+        new_m.setdefault("raw_files", current.get("raw_files", []))
+        new_m.setdefault("artifacts", current.get("artifacts", []))
+        new_m.setdefault("last_ingested", current.get("last_ingested", {}))
+        save_manifest(project_name, new_m)
+        manifest = new_m
+    elif isinstance(patch, dict):
+        # shallow merge
+        for k, v in patch.items():
+            # restrict some keys to sane types
+            if k in ("raw_files", "artifacts") and not isinstance(v, list):
+                continue
+            current[k] = v
+        save_manifest(project_name, current)
+        manifest = current
+    else:
+        resp = web.json_response(
+            {"ok": False, "error": "Expected either 'manifest' (dict) or 'patch' (dict) in body."},
+            status=400,
+        )
+        resp.headers["Access-Control-Allow-Origin"] = "*"
+        return resp
+
+    resp = web.json_response({"ok": True, "project": project_name, "manifest": manifest})
+    resp.headers["Access-Control-Allow-Origin"] = "*"
+    return resp
+
+async def handle_classify(request: web.Request) -> web.Response:
+    """
+    POST /classify
+    JSON body:
+      {
+        "project": "myproj" (optional, default = default),
+        "text": "string to classify",
+        "labels": ["label-a", "label-b", ...] (optional),
+        "system": "extra system prompt" (optional)
+      }
+
+    Returns:
+      {
+        "ok": true,
+        "project": "...",
+        "label": "chosen_label",
+        "explanation": "...",
+        "raw": "<model full response>"
+      }
+
+    If labels are omitted, the model will infer a short free-form label.
+    """
+    try:
+        payload = await request.json()
+    except Exception:
+        resp = web.json_response({"ok": False, "error": "Expected JSON body."}, status=400)
+        resp.headers["Access-Control-Allow-Origin"] = "*"
+        return resp
+
+    if not isinstance(payload, dict):
+        resp = web.json_response({"ok": False, "error": "Body must be a JSON object."}, status=400)
+        resp.headers["Access-Control-Allow-Origin"] = "*"
+        return resp
+
+    project_param = (payload.get("project") or "").strip()
+    project_name = safe_project_name(project_param) if project_param else DEFAULT_PROJECT_NAME
+    ensure_project_scaffold(project_name)
+
+    text = (payload.get("text") or "").strip()
+    if not text:
+        resp = web.json_response({"ok": False, "error": "Missing 'text' to classify."}, status=400)
+        resp.headers["Access-Control-Allow-Origin"] = "*"
+        return resp
+
+    labels = payload.get("labels")
+    if isinstance(labels, list):
+        labels = [str(x) for x in labels if str(x).strip()]
+    else:
+        labels = []
+
+    extra_system = (payload.get("system") or "").strip()
+
+    # Build a very small classification prompt
+    sys_lines = [
+        "You are a classification assistant. Respond in strict JSON with keys: label, explanation.",
+    ]
+    if labels:
+        sys_lines.append("You MUST choose exactly one of these labels:")
+        for lb in labels:
+            sys_lines.append(f"- {lb}")
+    else:
+        sys_lines.append("Infer a short, lowercase label (1â€“3 words) that best describes the text.")
+
+    if extra_system:
+        sys_lines.append("")
+        sys_lines.append("Additional instructions from caller:")
+        sys_lines.append(extra_system)
+
+    system_prompt = "\n".join(sys_lines)
+
+    messages: List[Dict[str, str]] = [
+        {"role": "system", "content": system_prompt},
+        {"role": "user", "content": text},
+    ]
+
+    try:
+        raw = await asyncio.to_thread(call_openai_chat, messages)
+    except Exception as e:
+        resp = web.json_response({"ok": False, "error": f"Model call failed: {e!r}"}, status=500)
+        resp.headers["Access-Control-Allow-Origin"] = "*"
+        return resp
+
+    label = ""
+    explanation = ""
+
+    # Try to interpret JSON if present
+    try:
+        m = re.search(r"\{.*\}", raw, flags=re.DOTALL)
+        if m:
+            obj = json.loads(m.group(0))
+            if isinstance(obj, dict):
+                label = str(obj.get("label") or "").strip()
+                explanation = str(obj.get("explanation") or "").strip()
+    except Exception:
+        pass
+
+    if not label:
+        # Fallback: first non-empty line
+        for ln in raw.splitlines():
+            ln = ln.strip()
+            if ln:
+                label = ln
+                break
+
+    resp = web.json_response(
+        {
+            "ok": True,
+            "project": project_name,
+            "label": label,
+            "explanation": explanation,
+            "raw": raw,
+        }
+    )
+    resp.headers["Access-Control-Allow-Origin"] = "*"
+    return resp
 async def handle_health(request: web.Request) -> web.Response:
     """GET /health
 
@@ -3603,6 +3801,9 @@
     ws_server = await websockets.serve(handle_connection, host, ws_port, ping_interval=None)
 
     app = web.Application()
+    app.router.add_get("/manifest", handle_get_manifest)
+    app.router.add_post("/manifest", handle_update_manifest)
+    app.router.add_post("/classify", handle_classify)
     app.router.add_get("/health", handle_health)
     app.router.add_post("/upload", handle_file_upload)
     app.router.add_get("/list_project", handle_list_project)
