<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI Workstation UI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<script>
  // Surface JS crashes in the chat so "no response" is never silent.
  window.addEventListener("error", (ev) => {
    try {
      console.error("[UI] window.onerror:", ev.error || ev.message || ev);
      if (typeof appendInfo === "function") {
        appendInfo("[ERROR] UI script crashed. Open DevTools Console.");
      }
    } catch (_) {}
  });

  window.addEventListener("unhandledrejection", (ev) => {
    try {
      console.error("[UI] unhandledrejection:", ev.reason || ev);
      if (typeof appendInfo === "function") {
        appendInfo("[ERROR] UI promise rejection. Open DevTools Console.");
      }
    } catch (_) {}
  });

  // iOS Safari sometimes stays "zoomed" after a textarea blur.
  // This forces a viewport recalculation on blur by temporarily clamping max scale.
  (function () {
    const vp = document.querySelector('meta[name="viewport"]');
    if (!vp) return;

    const original = vp.getAttribute("content") || "width=device-width, initial-scale=1.0";

    window.__lens0Viewport = {
      original,
      clampForReset() {
        vp.setAttribute("content", "width=device-width, initial-scale=1.0, maximum-scale=1.0");
      },
      restore() {
        vp.setAttribute("content", original);
      }
    };
  })();
</script>

  <link rel="icon" href="data:," />
  <style>
    :root {
      /* Default light = near-white (expert tint may override via JS) */
      --bg: #ffffff;
      --bg-elevated: #ffffff;
      --bg-chat-user: #e5f0ff;        /* toned-down light blue */
      --bg-chat-assistant: #e6f4ea;   /* toned-down light green */
      --bg-chat-system: #e5e7eb;      /* neutral gray for info */
      --text-main: #111827;
      --text-subtle: #6b7280;
      --border-subtle: #d1d5db;
      --accent: #2563eb;
      --accent-soft: #dbeafe;
      --danger: #b91c1c;
    }
    :root.dark {
      /* Default dark = near-black (expert tint may override via JS) */
      --bg: #000000;
      --bg-elevated: #050505;

      /* Only user has a bubble; still keep these sane */
      --bg-chat-user: rgba(255,255,255,0.08);
      --bg-chat-assistant: transparent;
      --bg-chat-system: rgba(255,255,255,0.06);

      --text-main: #f3f4f6;
      --text-subtle: #9ca3af;

      /* subtle borders in true dark */
      --border-subtle: rgba(255,255,255,0.10);

      --accent: #60a5fa;
      --accent-soft: rgba(96,165,250,0.20);
      --danger: #ef4444;
    }

    #debugPanel {
      position: fixed;
      right: 14px;
      bottom: 14px;
      width: 320px;
      max-width: calc(100vw - 28px);
      background: var(--bg-elevated);
      color: var(--text-main);
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 12px;
      z-index: 300;
      display: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    }
    #debugPanel.visible { display: block; }
    #debugPanel .row { display: flex; justify-content: space-between; gap: 8px; }
    #debugPanel .muted { color: var(--text-subtle); }
    #debugPanel pre {
      white-space: pre-wrap;
      word-break: break-word;
      margin: 6px 0 0 0;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "Avenir Next", "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      background: var(--bg);
      color: var(--text-main);
      font-size: 16px; /* ChatGPT-like base size */
    }

    /* Main layout: two-column on desktop, stacked on mobile */
    .root {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    #left, #right {
      padding: 8px;
      box-sizing: border-box;
    }

    #left {
      flex: 1;
      border-right: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
    }

    #right {
      display: none;
    }

    @media (max-width: 800px) {
      .root {
        flex-direction: column;
      }
      #left {
        border-right: none;
        border-bottom: 1px solid var(--border-subtle);
      }
      #right {
        order: -1; /* right controls appear above chat on mobile */
      }
    }

    /* Top bar: title + project name + status + theme */
    #topBar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      font-size: 12px;
      gap: 8px;
      flex-wrap: nowrap;
      position: relative; /* allow true center control */
    }

    /* Batch progress bar (top bar) */
    #batchProgressTrack {
      position: fixed;
      left: 12px;
      right: 12px;
      top: 8px;
      height: 3px;
      border-radius: 999px;
      overflow: hidden;
      background: transparent;
      pointer-events: none;
      display: none;
      z-index: 4000;
    }
    #batchProgressBar {
      height: 100%;
      width: 0%;
      background: var(--accent);
      transition: width 320ms ease;
      filter: drop-shadow(0 0 6px var(--accent));
    }
    #batchProgressTrack.indeterminate #batchProgressBar {
      width: 30%;
      animation: batchSweep 1.2s ease-in-out infinite;
    }
    #batchProgressTrack.finalizing #batchProgressBar {
      width: 100%;
      animation: batchPulse 1.2s ease-in-out infinite;
    }
    @keyframes batchSweep {
      0% { transform: translateX(-40%); }
      50% { transform: translateX(120%); }
      100% { transform: translateX(220%); }
    }
    @keyframes batchPulse {
      0% { opacity: 0.5; }
      50% { opacity: 1; }
      100% { opacity: 0.5; }
    }

    /* Center control sits in true middle (independent of left/right widths) */
    #topBarCenter {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* only the pill is clickable */
    }
    #expertPill {
      pointer-events: auto;
      border: none;
      background: transparent;
      color: var(--accent);
      font-weight: 800;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 999px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #expertPill:active { transform: scale(0.98); }

    #topBarLeft {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
      flex: 1 1 auto;   /* left side can shrink/grow */
      min-width: 0;     /* allow pill text to ellipsis if needed elsewhere */
    }

    #appTitle {
      font-weight: 650;
      font-size: 14px;
    }

    .tag-pill {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      font-size: 12px;
      color: var(--text-subtle);
      background: rgba(148, 163, 184, 0.06);
      white-space: nowrap;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      line-height: 1;
    }

    #projectNamePill {
      border-color: rgba(37, 99, 235, 0.45);
      color: var(--accent);
      font-weight: 750;
      background: rgba(37, 99, 235, 0.08);
      padding-right: 14px; /* room for chevron */
    }
    #projectNamePill::after {
      content: "▾";
      font-size: 12px;
      opacity: 0.8;
      margin-left: 2px;
    }
    #projectNamePill:hover {
      background: rgba(37, 99, 235, 0.12);
      border-color: rgba(37, 99, 235, 0.55);
    }
    #projectNamePill:active {
      transform: scale(0.99);
    }

    #topBarRight {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: nowrap;  /* keep status + toggle together */
      flex: 0 0 auto;
    }

    /* --- Uploads indicator (top bar) --- */
    #uploadIndicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      padding: 8px 14px;
      font-size: 12px;
      position: relative;
      user-select: none;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #uploadIndicator:hover {
      background: rgba(148, 163, 184, 0.10);
    }
    #uploadIndicator:active {
      transform: scale(0.98);
    }

    .uploadDot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--text-subtle);
      opacity: 0.8;
    }
    /* animated when active */
    #uploadIndicator.active .uploadDot {
      background: var(--accent);
      animation: uploadPulse 1.1s ease-in-out infinite;
      opacity: 1;
    }
    @keyframes uploadPulse {
      0% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.6); opacity: 1; }
      100% { transform: scale(1); opacity: 0.6; }
    }

    .uploadLabel { white-space: nowrap; }
    .uploadBadge {
      min-width: 18px;
      height: 18px;
      padding: 0 6px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.16);
      border: 1px solid rgba(37, 99, 235, 0.35);
      color: var(--accent);
      font-weight: 750;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      line-height: 18px;
    }

    /* Dropdown, mirrored from projectMenu but on the right */
    #uploadMenu {
      position: absolute;
      top: 52px;
      right: 12px;
      width: min(360px, calc(100vw - 24px));
      max-height: min(520px, 60vh);
      overflow: auto;
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      box-shadow: 0 14px 34px rgba(0, 0, 0, 0.18);
      padding: 10px;
      z-index: 9999;
    }
    .uploadMenuHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 8px 10px 8px;
      border-bottom: 1px solid var(--border-subtle);
      margin-bottom: 8px;
    }
    .uploadMenuHeaderTitle {
      font-weight: 750;
      font-size: 13px;
    }
    .uploadItem {
      border: 1px solid var(--border-subtle);
      border-radius: 12px;
      padding: 10px;
      margin-bottom: 8px;
      background: rgba(0,0,0,0.02);
    }
    .uploadItemTop {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 10px;
    }
    .uploadItemName {
      font-weight: 650;
      font-size: 12px;
      word-break: break-word;
    }
    .uploadItemStatus {
      font-size: 11px;
      color: var(--text-subtle);
      white-space: nowrap;
      flex: 0 0 auto;
    }
    .uploadItemActions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .uploadMiniBtn {
      padding: 4px 8px;
      font-size: 12px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
    }
    .uploadMiniBtn.primary {
      border-color: rgba(37, 99, 235, 0.45);
      background: rgba(37, 99, 235, 0.10);
      color: var(--accent);
      font-weight: 700;
    }
    .uploadDetail {
      margin-top: 8px;
      white-space: pre-wrap;
      font-size: 12px;
      color: var(--text-main);
      border-top: 1px dashed var(--border-subtle);
      padding-top: 8px;
      display: none;
    }
    .uploadItem.open .uploadDetail { display: block; }

    #status {
      font-size: 11px;
      color: var(--text-subtle);
      white-space: nowrap;
    }

    #themeToggle {
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: transparent;
      color: var(--text-subtle);
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
    }

    button {
      padding: 6px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
    }

    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      font-weight: 600;
    }

    /* "Search" button: same shape/weight as Send, different fill */
    button.primary.search {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
      font-weight: 700;
    }

    button.small {
      padding: 4px 8px;
      font-size: 12px;
    }

    button.danger {
      border-color: var(--danger);
      color: var(--danger);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Chat log */
    #logContainer {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-radius: 12px;

      /* No frame around the conversation */
      border: none;

      background: transparent;

      /* Let text go wider */
      padding: 0;

      overflow: hidden;
      position: relative;
    }

    #log {
      flex: 1;
      min-height: 0;     /* critical: allow it to shrink instead of forcing overflow */
      overflow-y: auto;

      /* Wider text area (less wasted margin) */
      padding: 0 10px;

      /* remove old single-side pad */
      padding-right: 10px;
    }

    .chat-bubble {
      position: relative;    /* allows per-message corner icon */
      max-width: 95%;
      margin: 6px 0;
      padding: 8px 10px;
      border-radius: 16px;
      font-size: 16px;       /* bigger text in bubbles */
      line-height: 1.65;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-weight: 500;      /* slightly bolder for readability */
    }

    /* Per-message copy icon (two-square) */
    .bubble-copy {
      position: absolute;
      bottom: 2px;
      right: 8px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-subtle);
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      user-select: none;
    }
    .bubble-copy:active { transform: scale(0.96); }
    .bubble-copy:hover { border-color: var(--border-subtle); }
    .chat-user {
      margin-left: auto;
      background: var(--bg-chat-user);
      color: var(--text-main);
      border-bottom-right-radius: 4px;
    }
    .chat-assistant {
      margin-right: auto;

      /* Only the user gets a “bubble”.
         Assistant content should take full width for legibility. */
      background: transparent;
      color: var(--text-main);

      border: none;
      border-radius: 0;

      /* tighter horizontal padding so text can run wide */
      padding: 4px 6px;     /* breathing room like ChatGPT */
      max-width: 96%;
    }

    /* Keep user bubbles as-is; just let assistant go wide */
    .chat-user {
      max-width: 92%;
    }

    .chat-info {
      margin: 4px auto;
      background: var(--bg-chat-system);
      color: var(--text-main);
      border-radius: 999px;
      font-size: 11px;
      max-width: 80%;
      text-align: center;
      font-weight: 600;
      border: 1px solid rgba(148, 163, 184, 0.18); /* visible separation in dark mode */
    }

    .timestamp {
      display: block;
      font-size: 11px;
      color: var(--text-subtle);
      margin-bottom: 2px;
      font-weight: 500;
    }

    /* Drop overlay for whole chat */
    #chatDropOverlay {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      background: rgba(37, 99, 235, 0.14);
      border: 2px dashed var(--accent);
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 13px;
      padding: 8px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }
    #chatDropOverlay.visible {
      opacity: 1;
      pointer-events: none;
    }

    /* Upload area / prompt */
    #upload-area {
      border-radius: 12px;
      border: 1px dashed var(--border-subtle);
      padding: 8px;
      background: rgba(148, 163, 184, 0.06);
      font-size: 13px;
    }

    #dropZone {
      border: 1px dashed var(--border-subtle);
      border-radius: 8px;
      padding: 8px;
      text-align: center;
      font-size: 12px;
      color: var(--text-subtle);
      background: rgba(148, 163, 184, 0.08);
    }
    #dropZone.dragover {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }

    #fileInput {
      font-size: 12px;
      width: 100%;
      margin-top: 4px;
    }
    .muted {
      color: var(--text-subtle);
      font-size: 12px;
    }
    #searchHelp {
      font-size: 11px;
      line-height: 1.25;
    }

    #input-area {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #attachBtn {
      position: absolute;
      left: 10px;
      top: 8px;

      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;

      background: transparent;
      border: none;
      border-radius: 0;

      color: var(--text-main);
      font-size: 22px;
      line-height: 1;
      font-weight: 800;

      padding: 0;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #attachBtn:hover {
      color: var(--accent);
    }
    #attachBtn:active {
      transform: scale(0.96);
      color: var(--accent);
    }


    #prompt {
      width: 100%;
      height: 95px;
      min-height: 42px;
      resize: vertical;
      font: 13px/1.4 "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      padding: 8px 8px 8px 40px; /* left padding to clear + glyph */
      border-radius: 8px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
    }

    /* Idle state: no focus AND no text (more reading room) */
    #composerWrap.compact #prompt {
      height: 15px;
    }
    #composerWrap {
      position: relative;
      width: 100%;
    }

    /* Hidden by default; enabled on mobile below */
    #composerChips {
      display: none;
    }

    button.chip {
      padding: 10px 14px;
      font-size: 14px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    button.chip.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      font-weight: 700;
    }

    /* Right side sections */
    .section-box {
      border: 1px solid var(--border-subtle);
      border-radius: 10px;
      padding: 8px;
      font-size: 13px;
      background: var(--bg-elevated);
    }
    .section-box h4,
    .section-box h5 {
      margin: 0 0 4px 0;
      font-size: 13px;
      font-weight: 600;
    }
    .flex-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    #projectSummary,
    #projectFiles {
      font-size: 12px;
      max-height: 120px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    #projectList {
      font-size: 12px;
      max-height: 120px;
      overflow-y: auto;
      border: 1px solid var(--border-subtle);
      border-radius: 6px;
      padding: 4px;
      margin-top: 4px;
    }
    #projectNameInput,
    #uploadProject,
    #commandInput {
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
    }
    #commandInput {
      width: 160px;
    }

    /* How-to panel */
    #howToList li {
      margin-bottom: 2px;
    }

    /* --- Mobile "ChatGPT-like" layout --- */
    @media (max-width: 800px) {
      html, body {
        height: 100%;
        overflow: hidden; /* prevent page from scrolling */
      }
      body {
        font-size: 16px;
      }
      .root {
        height: 100dvh;   /* dynamic viewport height (fixes mobile toolbar issues) */
        overflow: hidden;
      }
      #left {
        height: 100%;
        min-height: 0;    /* critical for flex children to size correctly */
        padding: 8px;
        gap: 8px;
      }
      /* Sticky header */
      /* Mobile: remove extra “bubbly” chrome in the header */
      .tag-pill {
        border: none;
        background: transparent;
        padding: 0 6px;
      }

      /* Project pill: keep readable but not huge */
      #projectNamePill {
        max-width: 38vw;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 0 6px;
      }

      /* Uploads: icon-only on mobile */
      #uploadIndicator {
        border: none;
        background: transparent;
        padding: 0 6px;
      }
      #uploadIndicator .uploadLabel { display: none; }

      /* Status: dot only (no “Connected” word) */
      #status {
        display: none;
      }

      /* Chat takes all remaining space */
      #logContainer {
        flex: 1;
        min-height: 0;
      }
      #log {
        padding-bottom: 0px;
      }
      .chat-bubble {
        font-size: 17px;
        line-height: 1.65;
        max-width: 92%;
      }
      /* Dock composer at bottom */
      #searchHelp {
        display: none;
      }
      #input-area {
        position: sticky;
        bottom: 0;
        z-index: 40;
        background: var(--bg);

        /* slightly tighter so buttons feel centered */
        padding-top: 4px;
        padding-bottom: calc(4px + env(safe-area-inset-bottom));

        border-top: 1px solid var(--border-subtle);
      }
      #prompt {
        font: 16px/1.35 system-ui, -apple-system, "Segoe UI", sans-serif;
        height: 64px;
        min-height: 44px;
        resize: none;
        border-radius: 14px;

        /* reduce wasted space while still clearing the chips */
        padding: 10px 12px 46px 42px;
      }
      /* Inline chips inside the composer (mobile only) */
      #composerChips {
        display: flex;
        position: absolute;
        right: 10px;
        bottom: 10px;

        gap: 8px;
        align-items: center;
        justify-content: flex-end;
        pointer-events: auto;
      }

      /* Normal (non-compact) baseline: + matches Send row */
      #attachBtn {
        top: auto !important;
        bottom: 10px !important;
      }

      /* Compact (idle) baseline: center + and Send vertically in the shrunken bar
         Use margins (NOT transforms) so :active scaling doesn't “jump” the button. */
      #composerWrap.compact #composerChips {
        top: 50%;
        bottom: auto;
        margin-top: -15px; /* half of chip row height (optical) */
      }

      #composerWrap.compact #attachBtn {
        top: 50% !important;
        bottom: auto !important;
        margin-top: -20px; /* nudge up 2px */
      }
      /* Compact (idle) chip state: smaller footprint for reading room */
      #composerWrap.compact #composerChips button.chip {
        padding: 4px 8px;
        font-size: 12px;
        opacity: 0.85;
      }

      #composerWrap.compact #composerChips button.chip.primary {
        font-weight: 600;
      }

      /* Collapse reserved space when idle */
      #composerWrap.compact #prompt {
        /* Compact idle state: visually centered vs + and Send */
        height: 40px !important;

        /* Symmetric vertical padding so the “bar” reads even */
        padding-top: 8px !important;
        padding-bottom: 8px !important;

        /* Keep left padding to clear the + button */
        padding-left: 42px !important;

        /* Keep right padding so text doesn’t run under Send */
        padding-right: 12px !important;
      }

      /* Hide the old row buttons on mobile (chips replace them) */
      #sendBtn, #searchBtn {
        display: none;
      }
      /* Hide right pane on mobile (access via drawer) */
      #right {
        display: none;
      }
      /* Make the upload area compact */
      #upload-area {
        padding: 6px;
      }
      #dropZone {
        display: none;
      }
      #fileInput {
        margin-top: 0;
      }
    }
    /* --- Project dropdown menu (tap Project pill) --- */
    #projectMenu {
      position: absolute;
      top: 52px;
      left: 12px;
      width: min(320px, calc(100vw - 24px));
      max-height: min(420px, 55vh);
      overflow: auto;
      border-radius: 14px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      box-shadow: 0 12px 30px rgba(0,0,0,0.12);
      padding: 8px;
      z-index: 300;
    }

    .projectMenuTitle {
      font-size: 12px;
      color: var(--text-subtle);
      font-weight: 650;
      margin: 2px 4px 8px 4px;
    }
    .projectMenuCreateRow {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 6px 4px 10px 4px;
    }
    .projectMenuCreateRow input {
      flex: 1;
      min-width: 0;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      font-size: 13px;
      outline: none;
    }
    .projectMenuCreateRow button {
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(37, 99, 235, 0.35);
      background: rgba(37, 99, 235, 0.10);
      color: var(--accent);
      font-weight: 800;
      white-space: nowrap;
    }
    .projectMenuDangerBtn {
      width: 100%;
      text-align: left;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(185, 28, 28, 0.30);
      background: rgba(185, 28, 28, 0.08);
      color: var(--danger);
      font-size: 14px;
      font-weight: 800;
      cursor: pointer;
      margin: 6px 0 8px 0;
    }
    .projectMenuDangerBtn:active { transform: scale(0.99); }

    .projectMenuItem {
      width: 100%;
      text-align: left;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: transparent;
      color: var(--text-main);
      cursor: pointer;
      font-size: 14px;
      font-weight: 650;
    }
    .projectMenuItem:hover {
      background: rgba(148, 163, 184, 0.10);
      border-color: rgba(148, 163, 184, 0.22);
    }
    .projectMenuItem.current {
      background: rgba(37, 99, 235, 0.10);
      border-color: rgba(37, 99, 235, 0.25);
    }
    .projectMenuMeta {
      font-size: 12px;
      color: var(--text-subtle);
      font-weight: 550;
      white-space: nowrap;
    }

    #projectMenuBackdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: transparent;
      z-index: 250;
    }

    /* --- Login overlay --- */
    #loginOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 500;
      padding: 16px;
    }
    #loginCard {
      width: min(420px, 100%);
      border-radius: 16px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
    }
    #loginCard h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      font-weight: 700;
    }
    #loginForm {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #loginForm input {
      font-size: 14px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      background: var(--bg-elevated);
      color: var(--text-main);
      outline: none;
    }
    #loginError {
      color: var(--danger);
      font-size: 12px;
      min-height: 16px;
    }
    #loginRow {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }
    #loginBtn {
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: var(--accent);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
    }
    #loginBtn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    /* --- Rich message rendering (UI-only formatting) --- */
    .chat-bubble .msg {
      white-space: normal; /* allow structured elements */
    }

    /* More vertical rhythm (ChatGPT-like breathing room) */
    .chat-bubble .msg p {
      margin: 0 0 18px 0;
    }
    .chat-bubble .msg p:last-child {
      margin-bottom: 0;
    }

    /* Stronger hierarchy: headings must POP */
    .chat-bubble .msg h3 {
      margin: 28px 0 14px 0;
      font-size: 26px;        /* real “section” header */
      font-weight: 800;
      line-height: 1.25;
      letter-spacing: -0.01em;
    }
    /* Avoid huge top gap when a message starts with a heading */
    .chat-bubble .msg h3:first-child {
      margin-top: 6px;
    }

    .chat-bubble .msg h4 {
      margin: 20px 0 10px 0;
      font-size: 20px;        /* clear subheader step */
      font-weight: 750;
      line-height: 1.3;
      letter-spacing: -0.005em;
      color: var(--text-main);
    }
    .chat-bubble .msg h4:first-child {
      margin-top: 6px;
    }

    /* Optional: tiny divider feel without adding real lines */
    .chat-bubble .msg h3 + p,
    .chat-bubble .msg h4 + p {
      margin-top: 0;
    }

    /* Lists: more airy and readable */
    .chat-bubble .msg ul {
      margin: 12px 0 18px 26px;
      padding: 0;
    }
    .chat-bubble .msg li {
      margin: 6px 0;
    }

    /* Inline code: slightly larger + clearer */
    .chat-bubble .msg code {
      font: 14px/1.35 "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      background: rgba(148, 163, 184, 0.16);
      border: 1px solid rgba(148, 163, 184, 0.26);
      padding: 2px 8px;
      border-radius: 999px;
    }

    /* Fenced blocks: more breathing room + readability */
    .chat-bubble .msg pre {
      margin: 14px 0 18px 0;
      padding: 14px 14px;
      border-radius: 14px;
      border: 1px solid rgba(148, 163, 184, 0.28);
      background: rgba(148, 163, 184, 0.10);
      overflow-x: auto;
      white-space: pre;
    }
    .chat-bubble .msg pre code {
      display: block;
      font: 14px/1.65 "SF Mono", ui-monospace, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      background: transparent;
      border: none;
      padding: 0;
      border-radius: 0;
      white-space: pre;
    }

    .chat-bubble .msg a.code-link {
      text-decoration: none;
    }
    .chat-bubble .msg a.code-link code {
      cursor: pointer;
      text-decoration: none;
    }

    .chat-bubble .msg a {
      color: var(--accent);
      text-decoration: underline;
      word-break: break-all;
      cursor: pointer;
    }
    /* File previews (images) */
    .file-preview {
      margin-top: 8px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(148, 163, 184, 0.06);
    }
    .file-preview img {
      display: block;
      width: 100%;
      height: auto;
    }
    .file-preview .cap {
      padding: 8px 10px;
      font-size: 12px;
      color: var(--text-subtle);
      border-top: 1px solid rgba(148, 163, 184, 0.25);
      word-break: break-all;
    }

    /* Resume block: calm “card” with hierarchy */
    /* Resume UX: make it feel like a pro guiding the user */
    .resume-guide {
      margin: 0 0 8px 0;
      font-size: 13px;
      line-height: 1.35;
      color: var(--text-main);
      font-weight: 650;
    }
    .resume-guide .subtle {
      display: block;
      margin-top: 2px;
      color: var(--text-subtle);
      font-weight: 550;
    }

    .resume-next {
      border: 1px solid rgba(37, 99, 235, 0.35);
      background: rgba(37, 99, 235, 0.10);
      border-radius: 12px;
      padding: 10px 10px;
      margin: 8px 0 10px 0;
    }
    .resume-next .label {
      font-size: 11px;
      color: var(--text-subtle);
      letter-spacing: 0.2px;
      text-transform: uppercase;
      font-weight: 750;
      margin-bottom: 4px;
    }
    .resume-next .text {
      font-size: 14px;
      line-height: 1.4;
      font-weight: 700;
      color: var(--text-main);
    }
    .resume-next.clickable {
      cursor: pointer;
      text-decoration: none;
      color: inherit;
      display: block; /* anchor wrapper behaves like a card */
    }
    .resume-next.clickable:active {
      transform: scale(0.99);
    }
    .resume-next-link {
      margin-top: 8px;
    }
    .resume-next-link a.code-link code {
      display: inline-block;
      white-space: nowrap;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .resume-openrow {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin: 8px 0 4px 0;
    }
    .resume-openbtn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(37, 99, 235, 0.35);
      background: rgba(37, 99, 235, 0.10);
      color: var(--accent);
      font-weight: 850;
      text-decoration: none;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;     /* never wrap "Open" */
      flex: 0 0 auto;          /* don't shrink weirdly */
      min-width: 92px;         /* tap target */
    }
    .resume-openbtn:active { transform: scale(0.98); }
    .resume-openbtn code {
      background: transparent;
      border: none;
      padding: 0;
      border-radius: 0;
      font-weight: 650;
      color: var(--text-subtle);
    }

    .resume-card {
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(148, 163, 184, 0.07);
      border-radius: 12px;
      padding: 10px 10px;
    }
    .resume-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .resume-title strong {
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    .resume-kv {
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 6px 10px;
      font-size: 13px;
      line-height: 1.45;
    }
    .resume-k {
      color: rgba(15, 23, 42, 0.65); /* slightly stronger than subtle */
      font-weight: 700;
      white-space: nowrap;
    }
    .resume-v {
      color: var(--text-main);
      font-weight: 520;
      min-width: 0;
    }
    .resume-divider {
      height: 1px;
      background: rgba(148, 163, 184, 0.28);
      margin: 8px 0;
    }
  </style>
</head>
<body>
  <!-- Login overlay (blocks UI until authenticated) -->
  <div id="loginOverlay">
    <div id="loginCard">
      <h3>Login</h3>
      <div class="muted" style="margin-bottom:8px;">
        Enter your username and password to access your chats.
      </div>
      <form id="loginForm">
        <input id="loginUser" autocomplete="username" placeholder="Username" />
        <input id="loginPass" type="password" autocomplete="current-password" placeholder="Password" />
        <div id="loginError"></div>
        <div id="loginRow">
          <button id="loginBtn" type="submit">Login</button>
        </div>
      </form>
    </div>
  </div>

  <div class="root">
    <div id="left">
      <div id="topBar">
        <!-- Project dropdown (lightweight; replaces the mobile drawer UX) -->
        <div id="projectMenu" style="display:none;"></div>

        <!-- Expert dropdown (center) -->
        <div id="expertMenu" style="display:none;"></div>

        <div id="topBarLeft">
          <!-- Header title removed (compact / mobile-first). -->
          <span class="tag-pill" id="projectNamePill" title="Chats" aria-label="Chats"
      style="display:inline-flex; padding:6px 10px; font-weight:700; color:var(--text-subtle); border-color:rgba(148,163,184,0.35); background:rgba(148,163,184,0.06);">
  Chats ▾
</span>
        </div>

        <!-- Center: expert selector (hat) -->
        <div id="topBarCenter">
          <button id="expertPill" type="button" aria-label="Expert" title="Expert">Default ▾</button>
        </div>

        <div id="topBarRight">
          <button id="uploadIndicator" type="button" aria-label="Uploads" title="Uploads">
            <span class="uploadDot" aria-hidden="true"></span>
            <span class="uploadLabel">Uploads</span>
            <span id="uploadBadge" class="uploadBadge" style="display:none;">0</span>
          </button>

          <div id="uploadMenu" style="display:none;"></div>

          <span id="status">Disconnected</span>
          <button id="themeToggle" type="button">Dark mode: Off</button>
        </div>

        <div id="batchProgressTrack" aria-hidden="true">
          <div id="batchProgressBar"></div>
        </div>
      </div>

      <div id="logContainer">
        <div id="log"></div>
        <div id="chatDropOverlay">
          Drop files here to upload into this chat.
        </div>
      </div>
      <!-- Copy-chat button removed (use per-message ⧉ icon instead). -->

      <div id="input-area">
        <div id="composerWrap">
          <button id="attachBtn" type="button" aria-label="Attach files" title="Attach files">+</button>
          <input type="file" id="fileInput" multiple style="display:none;" />
          <textarea id="prompt" autocapitalize="sentences" autocomplete="off" enterkeyhint="enter"></textarea>
          <div id="composerChips">
            <button id="sendChip" class="chip primary" type="button">Send</button>
          </div>
        </div>
        <input id="iosFocusSink" type="text" inputmode="none" aria-hidden="true" tabindex="-1"
          style="position:fixed; left:-9999px; top:-9999px; opacity:0; height:0; width:0; font-size:16px;" />
        <div style="display:flex; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap;">
          <div style="display:flex; gap:6px; align-items:center;">
            <button id="sendBtn" class="primary">Send</button>
          </div>
        </div>
      </div>
    </div>

    <div id="right">
      <div class="section-box">
        <h4>How to use this</h4>
        <ul id="howToList" class="muted">
          <li>1) Connect and start a new chat.</li>
          <li>2) Drop files into the chat or upload box.</li>
          <li>3) Ask questions or give instructions.</li>
          <li>4) Use “Show plan” and “List files” to see the map.</li>
        </ul>
        <div class="flex-row">
          <button id="connectBtn" class="primary small">Connect</button>
          <button id="disconnectBtn" class="small danger">Disconnect</button>
        </div>
      </div>

      <div class="section-box">
        <h4>Chat status</h4>
        <div class="muted" id="currentProjectLine">Chat: default</div>
        <div class="muted" id="currentGoalLine">Goal: (none yet)</div>
        <div style="margin-top:4px;">
          <button id="refreshPlanBtn" class="small">Show plan</button>
          <button id="refreshFilesBtn" class="small">List files</button>
        </div>
        <div id="projectSummary" style="margin-top:4px;"></div>
      </div>

      <div class="section-box">
        <h4>Files & artifacts</h4>
        <div id="projectFiles">(no data yet)</div>
      </div>

      <div class="section-box">
        <h4>Chats</h4>
        <button id="refreshProjectsBtn" class="small">Refresh chat list</button>
        <div id="projectList">(no chats loaded yet)</div>
        <div style="font-size:12px; margin-top:4px;">
          New / switch chat:
        <button id="newChatBtn" class="small">New chat</button>
        </div>
      </div>

      <div class="section-box">
        <h4>Quick commands</h4>
        <div style="font-size:12px; margin-bottom:4px;">
          Examples:
          <code>plan</code>,
          <code>list</code>,
          <code>Goal: build a dashboard</code>,
          <code>save: project_brief</code>
        </div>
        <div style="display:flex; gap:4px; align-items:center;">
          <input id="commandInput" placeholder="Type a command, e.g. plan" />
          <button id="runCommandBtn" class="small">Run</button>
        </div>
      </div>

      <p class="muted" style="margin-top:auto;">
        This UI is just a shell. All smarts are in ws://localhost:8765 and your local files.
        You can’t break anything important by clicking or dragging files around.
      </p>
    </div>
  </div>

  <div id="mobileDrawerBackdrop" style="
    position:fixed; inset:0; background:rgba(0,0,0,0.35);
    display:none; z-index:200;">
  </div>

  <div id="mobileDrawer" style="
    position:fixed; top:0; right:-92%; width:92%; height:100%;
    background:var(--bg-elevated); border-left:1px solid var(--border-subtle);
    z-index:210; transition:right 0.18s ease-out; padding:10px; overflow:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
      <strong>Projects</strong>
      <button id="closeDrawerBtn" class="small" type="button">Close</button>
    </div>
    <div id="drawerContent" style="margin-top:10px;"></div>
  </div>
  <div id="debugPanel">
    <div class="row" style="align-items:center;">
      <strong>Debug</strong>
      <div style="display:flex; gap:6px; align-items:center;">
        <span class="muted">Ctrl+Shift+D / Ctrl+Shift+T</span>
        <button id="debugTraceDumpBtn" class="small" type="button">Dump server trace</button>
        <button id="debugHideBtn" class="small" type="button">Hide</button>
      </div>
    </div>
    <div id="debugUsageSummary" style="margin-top:6px;"></div>
    <pre id="debugUsageDetails" class="muted"></pre>
    <div id="debugTraceSummary" style="margin-top:8px;"></div>
    <pre id="debugTraceDetails" class="muted"></pre>
  </div>
  <div id="projectMenuBackdrop"></div>
  <script>
// HTTP API should go to the same origin+port that served this page.
// If you're on localhost:8766, this keeps the port (critical for /login).
const API_ORIGIN = (() => {
  try {
    const u = new URL(window.location.href);
    // If UI is ever served from ws.<domain>, strip the ws. for HTTP calls
    u.hostname = u.hostname.replace(/^ws\./, "").replace(/^www\./, "");
    return u.origin;
  } catch (_) {
    return window.location.origin;
  }
})();

// WebSocket URL: derive ws_port from GET /health so we never guess ports.
let WS_URL = ""; // filled by ensureEndpoints()
let ENDPOINTS_READY = false;

async function ensureEndpoints() {
  if (ENDPOINTS_READY && WS_URL) return;

  const wsProto = (window.location.protocol === "https:") ? "wss" : "ws";
  const httpHost = window.location.hostname.replace(/^www\./, "").replace(/^ws\./, "");

  const isLocal =
    httpHost === "localhost" ||
    httpHost === "127.0.0.1" ||
    httpHost === "0.0.0.0" ||
    /^\d{1,3}(\.\d{1,3}){3}$/.test(httpHost);

  // WS host preference:
  // ? Local: direct host:ws_port
  // ? Public: prefer ws.<host> first (your proxy terminates WS there),
  //           then fall back to SAME host.
  const wsHostPrimary = isLocal ? httpHost : ("ws." + httpHost);
  const wsHostAlt = httpHost;
  // Default guess (only used if /health fails)
  let wsPortGuess = (window.location.port === "8766") ? "8765" : window.location.port;


  try {
    const r = await fetch(`${API_ORIGIN}/health`, { credentials: "include" });
    if (r.ok) {
      const data = await r.json().catch(() => ({}));
      if (data && data.ws_port) wsPortGuess = String(data.ws_port);
    }
  } catch (_) {}

  // Port rules:
  // ? Localhost/dev: use explicit ws_port (e.g., 8765)
  // ? Public domain: DO NOT append ports; your working "old" UI proved ws.<domain> works on 443.
  const pagePort = (window.location.port || "").trim();
  const wsPort = (wsPortGuess || "").trim();

  let portSuffix = "";
  if (isLocal) {
    portSuffix = wsPort ? (":" + wsPort) : "";
  } else if (pagePort) {
    // If you somehow serve the UI on a nonstandard public port, keep parity.
    portSuffix = ":" + pagePort;
  } else {
    // Public/proxied: rely on 443/80 (no explicit port)
    portSuffix = "";
  }

  // Primary WS target:
  // ? Public: ws.<host> first (matches your working endpoint on 443)
  // ? Local: host stays the same anyway
  const primary = `${wsProto}://${wsHostPrimary}${portSuffix}`;

  // Fallback WS target:
  // ? Public: SAME host
  // ? Local: same as primary (harmless)
  const fallback = `${wsProto}://${wsHostAlt}${portSuffix}`;

  WS_URL = primary;
  window.__lens0WsFallback = fallback;

  console.log("[WS] primary =", WS_URL, "fallback =", window.__lens0WsFallback, "ws_port =", wsPortGuess, "isLocal =", isLocal);



  ENDPOINTS_READY = true;
}

// Upload + list_projects should hit the HTTP origin
const BASE_UPLOAD_URL = `${API_ORIGIN}/upload`;
// Always send/receive cookies for API calls (login cookie + session).
// This is required when the UI is not served from the exact same origin as the API.
(() => {
  const _fetch = window.fetch.bind(window);
  window.fetch = (input, init = {}) => {
    // init overwrites defaults if it already specifies credentials
    return _fetch(input, { credentials: "include", ...init });
  };
})();

    const dropZone = document.getElementById("dropZone");
    const fileInput = document.getElementById("fileInput");
    const attachBtn = document.getElementById("attachBtn");
    if (attachBtn && fileInput) {
      attachBtn.addEventListener("click", () => fileInput.click());
    }

    const uploadProjectInput = document.getElementById("uploadProject");

    // WebSocket handle (must be global; used by connect/disconnect/login gating)
    let ws = null;
    // --- WS heartbeat / liveness ---
    const WS_HEARTBEAT_MS = 20000;   // 20s ping
    // Be tolerant of laptops sleeping / timers pausing / background throttling.
    // 3 minutes is too aggressive for real-world idle; use 15 minutes.
    const WS_DEAD_MS = 900000;       // consider dead if no pong in 15 minutes
    let wsHeartbeatTimer = null;
    let wsLastPongAt = 0;
    let wsLastHeartbeatTickAt = 0;   // used to detect timer pauses (sleep/wake)


    function startWsHeartbeat() {
      stopWsHeartbeat();
      wsLastPongAt = Date.now();
      wsLastHeartbeatTickAt = wsLastPongAt;

      wsHeartbeatTimer = setInterval(() => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;

        const now = Date.now();
        const tickGap = wsLastHeartbeatTickAt ? (now - wsLastHeartbeatTickAt) : 0;
        wsLastHeartbeatTickAt = now;

        // If timers were paused (sleep/wake, heavy throttling), don't treat the stale pong time as a dead socket.
        // Reset the "last pong" marker and continue.
        if (tickGap && tickGap > (WS_HEARTBEAT_MS * 6)) {
          wsLastPongAt = now;
        }

        // If we haven't seen a pong in too long, hard reset.
        // BUT: during long-running server work (deliverables), the WS can be quiet.
        // If the UI is actively showing "thinking…", do NOT self-close.
        if (now - wsLastPongAt > WS_DEAD_MS) {
          const uiBusy =
            (typeof thinkingActive !== "undefined" && thinkingActive) ||
            (window.BatchProgress && typeof window.BatchProgress.isActive === "function" && window.BatchProgress.isActive());
          if (uiBusy) {
            console.warn("[WS] heartbeat timeout, but UI is in thinking state - not closing socket");
            wsLastPongAt = now;
            return;
          }

          // If the tab is visible but the device likely slept, don't force-close; just reset and keep going.
          // (The next ping/pong will prove liveness.)
          wsLastPongAt = now;
        }

        try {
          // Preferred heartbeat frame (v1). Server replies with {v:1,type:"ws.pong"}.
        const frame = { v: 1, type: "ws.ping" };
        attachTrace(frame, "send");
        ws.send(JSON.stringify(frame));
        } catch (e) {
          console.warn("[WS] ping send failed", e);
        }
      }, WS_HEARTBEAT_MS);
    }

    function stopWsHeartbeat() {
      if (wsHeartbeatTimer) {
        clearInterval(wsHeartbeatTimer);
        wsHeartbeatTimer = null;
      }
    }

    // --- Auth / login gating ---
    const loginOverlay = document.getElementById("loginOverlay");
    const loginForm = document.getElementById("loginForm");
    const loginUser = document.getElementById("loginUser");
    const loginPass = document.getElementById("loginPass");
    const loginBtn = document.getElementById("loginBtn");
    const loginError = document.getElementById("loginError");
    function isLoginVisible() {
      return !!(loginOverlay && loginOverlay.style.display !== "none");
    }

    function showLogin(message = "") {
      if (loginError) loginError.textContent = message || "";
      if (loginOverlay) loginOverlay.style.display = "flex";
      manualClose = true; // prevent reconnect loop until login succeeds
      if (ws) {
        try { ws.close(); } catch (_) {}
      }
      setStatus("Login required");
      // focus user field
      setTimeout(() => {
        try { loginUser && loginUser.focus(); } catch (_) {}
      }, 50);
    }

    function hideLogin() {
      if (loginOverlay) loginOverlay.style.display = "none";
      if (loginError) loginError.textContent = "";
    }
     // --- PWA auth persistence (iOS Add-to-Home Screen) ---
     // iOS may suspend/evict JS context when backgrounded, losing in-memory WS fallback creds.
     // Use sessionStorage (clears when Safari truly closes) to survive brief app switching.
     function loadSessionAuthIntoGlobals() {
       try {
         const u = (window.sessionStorage.getItem("lens0_auth_user") || "").trim();
         const p = (window.sessionStorage.getItem("lens0_auth_pass") || "").trim();
         if (u && p) {
           window.__LENS0_AUTH_USER = u;
           window.__LENS0_AUTH_PASS = p;
         }
       } catch (_) {}
     }
     loadSessionAuthIntoGlobals();

     function persistSessionAuth(username, password) {
       try {
         window.sessionStorage.setItem("lens0_auth_user", (username || "").trim());
         window.sessionStorage.setItem("lens0_auth_pass", (password || "").trim());
       } catch (_) {}
     }
    async function doLogin(username, password) {
      const res = await fetch(`${API_ORIGIN}/login`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        credentials: "include",
        body: JSON.stringify({ username, password })
      });
      if (!res.ok) return false;
      const data = await res.json().catch(() => ({}));
      const ok = !!(data && data.ok);
       if (ok) {
         // TEMP: used to auth WS when cookies aren't present on WS handshake
         window.__LENS0_AUTH_USER = (username || "").trim();
         window.__LENS0_AUTH_PASS = (password || "").trim();

         // iOS PWA: persist for the lifetime of the web-app session (clears when Safari is truly closed).
         persistSessionAuth(username, password);
       }
      return ok;

    }

    if (loginForm) {
      loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const u = (loginUser && loginUser.value ? loginUser.value : "").trim();
        const p = (loginPass && loginPass.value ? loginPass.value : "").trim();
        if (!u || !p) {
          showLogin("Enter username + password.");
          return;
        }
        if (loginBtn) loginBtn.disabled = true;
        try {
          const ok = await doLogin(u, p);
          if (!ok) {
            showLogin("Login failed.");
            return;
          }

          hideLogin();
          // Arm continuity exactly once after login
          noteProjectSwitch("login");

          // Load per-user desired project now that we know who is logged in
          try {
            const perUser = (window.localStorage.getItem(projectStorageKey()) || "").trim();
            if (perUser) desiredProjectName = perUser;
          } catch (_) {}
          manualClose = false;
          connect();

          // After login, do NOT run UI deterministic welcome.
          // Greeting is handled by backend + thread.history + greeting.request.
          // setTimeout(() => {
          //   try { scheduleWelcome("login"); } catch (_) {}
          // }, 350);
        } catch (err) {
          showLogin("Login error.");
        } finally {
          if (loginBtn) loginBtn.disabled = false;
        }
      });
    }


    // --- Connection policy ---
    // This UI does NOT auto-reconnect. The backend is stateful; reconnects must be user-initiated.
    let manualClose = false;

    // --- Project switch intent (prevents onboarding/info from reappearing on mobile resume) ---
    // We only want the project "onboard" text to appear after:
    // - first login, or
    // - an explicit user-initiated project switch
    // NOT after background/resume reconnects.
    let lastProjectSwitchAt = 0;
    let lastProjectSwitchReason = ""; // "login" | "user" | "restore" | ""

    // --- Restore suppression (mobile Safari: pageshow -> reconnect -> server repeats Resume/Pulse blob) ---
    // When we auto-restore a project on reconnect, suppress the "Project Pulse / Resume" status blob
    // that the server emits again, so it doesn't look like a pop-up.
    let suppressRestoreBannersUntil = 0;
    let suppressRestoreProject = "";

    function looksLikeResumeOrPulseBlob(msg) {
      const s = String(msg || "");

      // STRICT: only match the real Resume/status blobs coming from the server.
      // Do NOT match normal assistant replies (they contain "Project Pulse" by design).
      if (s.includes("\nResume:") || s.startsWith("Resume:")) return true;

      return false;
    }

    function looksLikeBootstrapPulse(msg) {
      const s = String(msg || "");
      // Deterministic markers emitted by build_truth_bound_pulse() for new projects
      if (s.includes("Project is being initialized - goal not yet confirmed.")) return true;
      if (s.includes("Goal: (not set yet)")) return true;
      if (s.startsWith("Project Pulse (truth-bound)")) return true;
      return false;
    }

    function isBootstrapResumeBlob(msg) {
      const s = String(msg || "");
      // Deterministic: new project pulse always contains this banner from build_truth_bound_pulse().
      if (s.includes("Project is being initialized - goal not yet confirmed.")) return true;

      // Extra belt-and-suspenders: catch goal-not-set phrases
      if (s.includes("Goal: (not set yet)")) return true;

      return false;
    }
    function lastChatStorageKey(projectName) {
      const u = (window.__LENS0_AUTH_USER || "guest").trim() || "guest";
      const p = (projectName || currentProjectName || "default").trim() || "default";
      return `lens0-last-real-chat:${u}:${p}`;
    }

    function lastAssistantChatStorageKey(projectName) {
      const u = (window.__LENS0_AUTH_USER || "guest").trim() || "guest";
      const p = (projectName || currentProjectName || "default").trim() || "default";
      return `lens0-last-assistant-chat:${u}:${p}`;
    }

    function saveLastAssistantChat(projectName, role, ts, text) {
      try {
        const k = lastAssistantChatStorageKey(projectName);
        const payload = {
          role: role || "",
          ts: ts || "",
          text: (text == null) ? "" : String(text)
        };
        window.localStorage.setItem(k, JSON.stringify(payload));
      } catch (_) {}
    }

    function loadLastAssistantChat(projectName) {
      try {
        const k = lastAssistantChatStorageKey(projectName);
        const raw = window.localStorage.getItem(k);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return null;
        if (!obj.text || !obj.role) return null;
        return obj;
      } catch (_) {
        return null;
      }
    }

    function saveLastRealChat(projectName, role, ts, text) {
      try {
        const k = lastChatStorageKey(projectName);
        const payload = {
          role: role || "",
          ts: ts || "",
          text: (text == null) ? "" : String(text)
        };
        window.localStorage.setItem(k, JSON.stringify(payload));
      } catch (_) {}
    }

    function loadLastRealChat(projectName) {
      try {
        const k = lastChatStorageKey(projectName);
        const raw = window.localStorage.getItem(k);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return null;
        if (!obj.text || !obj.role) return null;
        return obj;
      } catch (_) {
        return null;
      }
    }

    // --- Continuity from disk artifacts (authoritative, minimal) ---
    // Goal: after a Resume/Pulse blob, fetch latest assistant_output_*.md from /list and append it.
    let __lastAnswerFetchPending = false;
    let __lastAnswerFetchProject = "";
    let __lastAnswerFetchAt = 0;

    function requestLatestAssistantOutput(projectName) {
      const p = (projectName || "").trim() || "default";
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      __lastAnswerFetchPending = true;
      __lastAnswerFetchProject = p;
      __lastAnswerFetchAt = Date.now();

      // Server already knows current project for this connection.
      // IMPORTANT: ws_commands requires explicit invocation ("!" or "/cmd"), otherwise it will fall through as normal chat.
      // Use canonical WS frame. Do NOT use send() here (we don't want a user bubble).
      try {
        const frame = {
          v: 1,
          type: "chat.send",
          text: "!last answer",
          project: (currentProjectName || p || "default"),
          active_expert: (activeExpert || "default"),
          intent: {}
        };
        attachTrace(frame, "send");
        ws.send(JSON.stringify(frame));
      } catch (_) {}
    }
    // --- Startup ownership (restore owns startup) ---
    // If a restore is happening, ONLY the restore path may trigger history load / last-answer.
    // We also suppress projectMeta-triggered history fetches briefly to avoid double-load.
    let __startupOwner = "";           // "restore" | "connect" | ""
    let __startupUntil = 0;            // epoch ms
    let __startupRestoreProject = "";  // desired project at time of startup
    // Connect-owned startup: wait for server to announce the real project before loading history.
    let __connectHistoryPending = false;

    function __inStartupWindow() {
      return Date.now() < (__startupUntil || 0);
    }    
    // --- Thread history de-dupe ---
    // Prevents "startup stutter" where we fetch history for default, then restore, then fetch again.
    const __threadGetLastAt = Object.create(null);   // project -> ts
    const __threadGetInFlight = Object.create(null); // project -> boolean

    function requestThreadHistoryOnce(projectName, reason) {
      const p = (projectName || "").trim() || "default";
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      const now = Date.now();
      const lastAt = __threadGetLastAt[p] || 0;

      // If we just requested this project very recently, skip.
      if ((now - lastAt) < 800) return;

      // If one is already in-flight for this project, skip.
      if (__threadGetInFlight[p]) return;

      __threadGetLastAt[p] = now;
      __threadGetInFlight[p] = true;

      try {
        const frame = { v: 1, type: "thread.get", project: p, reason: String(reason || "") };
        attachTrace(frame, "send");
        ws.send(JSON.stringify(frame));
      } catch (_) {
        __threadGetInFlight[p] = false;
      }

      // Safety release: if the server never replies for some reason, don't deadlock.
      setTimeout(() => { __threadGetInFlight[p] = false; }, 4000);
    }

    // Back-compat wrapper.
    function requestThreadHistory(projectName) {
      requestThreadHistoryOnce(projectName, "legacy");
    }

    function looksLikeServerListOutput(msg) {
      const s = String(msg || "");
      // Match your actual list output format used elsewhere in this UI.
      return (
        s.startsWith("Project:") &&
        s.includes("Documents:") &&
        (s.includes("Cheat sheets / artifacts:") || s.includes("Artifacts:")) &&
        s.includes("/file-path=")
      );
    }

    function parseLatestAssistantOutputHrefFromList(listText) {
      const s = String(listText || "");
      const lines = s.split(/\r?\n/);

      const candidates = [];
      for (let i = 0; i < lines.length; i++) {
        const ln = (lines[i] || "").trim();

        // Example: "- assistant_output_20251227_232527_v1.md [type=assistant_output, v1]"
        if (ln.startsWith("- ") && ln.includes("[type=assistant_output")) {
          const next = (lines[i + 1] || "").trim();
          const mHref = next.match(/\/file\-path=\S+/);
          if (!mHref) continue;

          const href = mHref[0];

          const mStamp = ln.match(/assistant_output_(\d{8}_\d{6})_v\d+\.md/i);
          const stampNum = mStamp ? Number(mStamp[1].replace("_", "")) : 0;

          candidates.push({ stampNum: isFinite(stampNum) ? stampNum : 0, href });
        }
      }

      if (!candidates.length) return "";
      candidates.sort((a, b) => (b.stampNum - a.stampNum));
      return candidates[0].href || "";
    }

    async function fetchAndAppendAssistantOutputHref(href) {
      if (!href) return;
      try {
        const url = href.startsWith("http") ? href : (API_ORIGIN + href);
        const res = await fetch(url, { credentials: "include" });
        if (!res.ok) return;

        const txt = await res.text();
        const cleaned = normalizeText(txt, 4).trim();
        if (!cleaned) return;

        // De-dupe: if this is already the most recent assistant message, do not append again.
        const p = activeProjectForStorage();
        const last = __lastAssistantByProject[p];
        if (last && last.text && last.text.trim() === cleaned) {
          return;
        }

        appendChat(cleaned, "assistant");
      } catch (_) {}
    }



    // --- Continuity arming (ONLY on login / explicit project switch; fires ONCE) ---
    let __continuityArmedUntil = 0;
    let __continuityArmedProject = "";
    let __continuityArmedReason = ""; // "login" | "user"

    function armContinuity(projectName, reason) {
      __continuityArmedProject = (projectName || "").trim() || "default";
      __continuityArmedReason = reason || "user";
      __continuityArmedUntil = Date.now() + 8000; // 8s window to catch the next Pulse/Resume blob
    }

    function disarmContinuity() {
      __continuityArmedUntil = 0;
      __continuityArmedProject = "";
      __continuityArmedReason = "";
    }

    function noteProjectSwitch(reason, targetProjectName) {
      lastProjectSwitchAt = Date.now();
      lastProjectSwitchReason = reason || "user";

      // Arm continuity for login/user AND restore so reconnects can resume naturally.
      if (lastProjectSwitchReason === "login" || lastProjectSwitchReason === "user" || lastProjectSwitchReason === "restore") {
        const target = (targetProjectName || desiredProjectName || currentProjectName || "default").trim() || "default";
        armContinuity(target, lastProjectSwitchReason);
      }
    }

    function parseProjectNameFromMsg(msg) {
      const s = String(msg || "");
      // common server formats already handled elsewhere
      const m1 = s.match(/(-:^|\n)\s*Project:\s*([^\n\r]+)/i);
      if (m1 && m1[1]) return m1[1].trim();

      const m2 = s.match(/(-:^|\n)\s*Current project:\s*([^\n\r]+)/i);
      if (m2 && m2[1]) return m2[1].trim();

      const m3 = s.match(/(-:^|\n)\s*Current project for this connection:\s*([^\n\r]+)/i);
      if (m3 && m3[1]) return m3[1].trim();

      const m4 = s.match(/(-:^|\n)\s*Switched current project for this connection to:\s*([^\n\r]+)/i);
      if (m4 && m4[1]) return m4[1].trim();

      const m5 = s.match(/(-:^|\n)\s*Started new project:\s*([^\n\r]+)/i);
      if (m5 && m5[1]) return m5[1].trim();

      return "";
    }
    // --- Background / inactivity handling (mobile reliability) ---
    // If the page is backgrounded, browsers often suspend WS and then throw noisy errors.
    // Keep the session alive for ~1 hour of inactivity/background before requiring login again.
     // iOS PWA: sockets can die while backgrounded with no clean signal.
     // If the WS closes while hidden, we should reconnect on resume.
     let wsClosedWhileHidden = false;    
     // Track whether we were connected when we went hidden (for auto-resume).
     let wasConnectedBeforeHidden = false;

     // Keep a short grace window after returning where auth-ish WS closes are treated as "background churn".
     let lastCameBackAt = 0;
     const RESUME_GRACE_MS = 8000;    
    const INACTIVITY_LOGIN_MS = 60 * 60 * 1000; // 60 minutes
    let lastHiddenAt = 0;

     function clearTransientAuth() {
       // Prevent leaking old creds into querystrings if WS reconnects later.
       try { window.__LENS0_AUTH_PASS = ""; } catch (_) {}
       // Also clear sessionStorage (PWA resume uses it).
       try { window.sessionStorage.removeItem("lens0_auth_pass"); } catch (_) {}
       // Keep username (helps UX), but pass must be re-entered after expiry.
     }

     function handleWentHidden() {
       lastHiddenAt = Date.now();
       wasConnectedBeforeHidden = !!(ws && ws.readyState === WebSocket.OPEN);
       wsClosedWhileHidden = false; // will be set by ws.onclose if the socket dies while hidden
       // No reconnect logic while backgrounded.
       setStatus("Background");
     }

     function handleCameBack() {
       const now = Date.now();
       const awayMs = lastHiddenAt ? (now - lastHiddenAt) : 0;
       lastCameBackAt = now;

       // DO NOT clear lastHiddenAt immediately - ws.onclose may fire after we return.
       // Clear it after the resume grace window so auth-ish WS closes are treated as background churn.
       setTimeout(() => { lastHiddenAt = 0; }, RESUME_GRACE_MS + 250);

       // If login is visible, do not attempt anything.
       if (isLoginVisible()) {
         setStatus("Login required");
         return;
       }

       // If away long enough, force re-login.
       if (awayMs >= INACTIVITY_LOGIN_MS) {
         clearTransientAuth();
         showLogin("Session expired - please log in again.");
         return;
       }

       // If socket is still open, mark connected and resume heartbeat.
       if (ws && ws.readyState === WebSocket.OPEN) {
         setStatus("Connected");
         startWsHeartbeat();
         return;
       }

       // iOS PWA: the socket often dies while hidden; reconnect on resume.
       // Do this even if we can't prove we were connected (iOS can kill WS before we record state).
       if (!manualClose && (wasConnectedBeforeHidden || wsClosedWhileHidden || !!lastHiddenAt)) {
         setStatus("Reconnecting…");
         try { loadSessionAuthIntoGlobals(); } catch (_) {}
         try { connect(); } catch (_) {}
         return;
       }

       setStatus("Disconnected");
     }

    document.addEventListener("visibilitychange", () => {
      if (document.hidden) handleWentHidden();
      else handleCameBack();
    });

    window.addEventListener("pagehide", () => { handleWentHidden(); });
    window.addEventListener("pageshow", () => { handleCameBack(); });

    const logEl = document.getElementById("log");
    const promptEl = document.getElementById("prompt");
    const composerChipsEl = document.getElementById("composerChips");

    // Bonus: clicking near the left gutter of the prompt opens upload (forgiving UX)
    // Must be defined AFTER promptEl exists.
    if (promptEl && fileInput) {
      promptEl.addEventListener("mousedown", (e) => {
        const rect = promptEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        if (x < 36) {
          e.preventDefault();
          fileInput.click();
        }
      });
    }

    function updateComposerChipState() {
      if (!promptEl) return;

      const wrap = document.getElementById("composerWrap");
      if (!wrap) return;

      const hasText = promptEl.value.trim().length > 0;
      const isFocused = document.activeElement === promptEl;

      // Compact only when idle: no focus AND no text
      if (!isFocused && !hasText) {
        wrap.classList.add("compact");
      } else {
        wrap.classList.remove("compact");
      }
    }
    // Mobile Safari: after a textarea blur, Safari can remain "zoomed" until another focus/gesture occurs.
    // Workaround: briefly focus a hidden 16px input (focus sink) to force Safari to drop back to normal scale.
    if (promptEl) {
      const iosSink = document.getElementById("iosFocusSink");

    promptEl.addEventListener("focus", () => {
      updateComposerChipState();
    });
      promptEl.addEventListener("blur", () => {
        // Re-evaluate idle/compact state when the keyboard dismisses
        updateComposerChipState();

        try {
          if (window.__lens0Viewport) {
            window.__lens0Viewport.clampForReset();
          }

          // Give Safari a beat to close the keyboard, then force a new focus target.
          setTimeout(() => {
            try {
              if (iosSink && typeof iosSink.focus === "function") {
                // preventScroll is supported in modern Safari; harmless if ignored.
                iosSink.focus({ preventScroll: true });
                iosSink.blur();
              }
            } catch (_) {}

            // Restore viewport after the focus nudge.
            if (window.__lens0Viewport) {
              window.__lens0Viewport.restore();
              // Nudge layout without moving the user.
              window.scrollTo(window.scrollX, window.scrollY);
            }

            // Re-check again after the focus nudge settles
            updateComposerChipState();
          }, 350);
        } catch (_) {}
      });
    }
    const sendBtn = document.getElementById("sendBtn");
    const statusEl = document.getElementById("status");
    const connectBtn = document.getElementById("connectBtn");
    const disconnectBtn = document.getElementById("disconnectBtn");
    const refreshProjectsBtn = document.getElementById("refreshProjectsBtn");
    const projectListEl = document.getElementById("projectList");
    const newChatBtn = document.getElementById("newChatBtn");
    const refreshPlanBtn = document.getElementById("refreshPlanBtn");
    const refreshFilesBtn = document.getElementById("refreshFilesBtn");
    const projectSummaryEl = document.getElementById("projectSummary");
    const projectFilesEl = document.getElementById("projectFiles");
    const currentProjectLine = document.getElementById("currentProjectLine");
    const currentGoalLine = document.getElementById("currentGoalLine");
    const commandInput = document.getElementById("commandInput");
    const runCommandBtn = document.getElementById("runCommandBtn");
    const sendChip = document.getElementById("sendChip");
    const themeToggle = document.getElementById("themeToggle");
    const chatDropOverlay = document.getElementById("chatDropOverlay");
    const projectNamePill = document.getElementById("projectNamePill");
    const logContainer = document.getElementById("logContainer");
    const debugPanel = document.getElementById("debugPanel");
    const debugUsageSummary = document.getElementById("debugUsageSummary");
    const debugUsageDetails = document.getElementById("debugUsageDetails");
    const debugTraceSummary = document.getElementById("debugTraceSummary");
    const debugTraceDetails = document.getElementById("debugTraceDetails");
    const debugTraceDumpBtn = document.getElementById("debugTraceDumpBtn");
    const debugHideBtn = document.getElementById("debugHideBtn");
        // Copy-chat button removed (we use per-message ⧉ icon now).
    // Keep a safe null reference so legacy code below doesn't crash.
    const copyChatBtn = null;

    // --- Debug panel (hidden) ---
    let debugVisible = false;
    let traceVisible = false;
    let lastUsageFrame = null;
    let lastTraceId = "";
    const traceEvents = [];
    const TRACE_EVENT_LIMIT = 20;
    let serverTraceDump = [];

    function newTraceId() {
      const rand = Math.floor(Math.random() * 0xffffffff).toString(16).slice(0, 8);
      return `ui_${Date.now()}_${rand}`;
    }

    function attachTrace(frame, dir, overrideType, updateLast) {
      if (!frame || typeof frame !== "object") return "";
      const tid = String(frame.trace_id || "").trim() || newTraceId();
      frame.trace_id = tid;
      const typ = String(overrideType || frame.type || "").trim();
      const ts = new Date().toISOString();
      if (updateLast) lastTraceId = tid;
      recordTraceEvent({ dir: dir || "", type: typ, trace_id: tid, ts });
      try { console.log("[TRACE]", dir || "", typ, tid); } catch (_) {}
      return tid;
    }

    function recordTraceEvent(evt) {
      if (!evt || typeof evt !== "object") return;
      traceEvents.push(evt);
      while (traceEvents.length > TRACE_EVENT_LIMIT) traceEvents.shift();
      if (traceVisible) renderTraceDebug();
    }

    function formatUsageLine(label, obj) {
      if (!obj) return `${label}: (none)`;
      const calls = Number(obj.calls || 0);
      const pt = Number(obj.prompt_tokens || 0);
      const ct = Number(obj.completion_tokens || 0);
      const tt = Number(obj.total_tokens || 0);
      return `${label}: calls ${calls} | in ${pt} | out ${ct} | total ${tt}`;
    }

    function renderUsageDebug() {
      if (!debugPanel || !debugUsageSummary || !debugUsageDetails) return;
      if (!lastUsageFrame) {
        debugUsageSummary.textContent = "Waiting for usage data...";
        debugUsageDetails.textContent = "";
        return;
      }
      const u = lastUsageFrame.usage || {};
      const tot = lastUsageFrame.total || {};
      const trace = String(lastUsageFrame.trace_id || "").trim();
      const ts = String(lastUsageFrame.ts || "").trim();
      const lines = [];
      lines.push(formatUsageLine("Turn", u));
      lines.push(formatUsageLine("Session", tot));
      if (trace) lines.push(`trace_id: ${trace}`);
      if (ts) lines.push(`ts: ${ts}`);
      debugUsageSummary.textContent = lines.join("  |  ");

      const byModel = (u.by_model && typeof u.by_model === "object") ? u.by_model : {};
      const modelLines = [];
      for (const [k, v] of Object.entries(byModel)) {
        modelLines.push(formatUsageLine(k, v));
      }
      debugUsageDetails.textContent = modelLines.join("\\n");
    }

    function renderTraceDebug() {
      if (!debugPanel || !debugTraceSummary || !debugTraceDetails) return;
      const t = String(lastTraceId || "").trim();
      const lines = [];
      lines.push(`trace_id: ${t || "(none)"}`);
      lines.push(`events: ${traceEvents.length}`);
      debugTraceSummary.textContent = lines.join("  |  ");
      const out = [];
      if (Array.isArray(serverTraceDump) && serverTraceDump.length) {
        out.push("SERVER TRACE DUMP (most recent first)");
        const dump = serverTraceDump.slice().reverse();
        for (const ev of dump) {
          if (!ev || typeof ev !== "object") continue;
          const ts = (ev.ts_monotonic == null) ? "" : String(ev.ts_monotonic);
          const typ = String(ev.event_type || "");
          const proj = String(ev.project || "");
          const cnt = (ev.count == null) ? "" : String(ev.count);
          let det = "";
          try {
            det = ev.detail ? JSON.stringify(ev.detail) : "";
          } catch (_) {
            det = "";
          }
          out.push(`${ts} ${typ} ${proj} ${cnt}${det ? " " + det : ""}`.trim());
        }
        out.push("");
      }
      out.push("RECENT TRACE (last 20)");
      for (const ev of traceEvents) {
        const dir = ev.dir || "";
        const typ = ev.type || "";
        const tid = ev.trace_id || "";
        const ts = ev.ts || "";
        out.push(`${dir} ${typ} ${tid} ${ts}`.trim());
      }
      debugTraceDetails.textContent = out.join("\\n");
    }

    function _setDebugPanelVisible() {
      if (!debugPanel) return;
      debugPanel.classList.toggle("visible", !!(debugVisible || traceVisible));
    }

    function toggleDebugPanel(force) {
      if (!debugPanel) return;
      debugVisible = (typeof force === "boolean") ? force : !debugVisible;
      _setDebugPanelVisible();
      if (debugVisible) renderUsageDebug();
    }

    function toggleTracePanel(force) {
      if (!debugPanel) return;
      traceVisible = (typeof force === "boolean") ? force : !traceVisible;
      _setDebugPanelVisible();
      if (traceVisible) renderTraceDebug();
    }

    function requestTraceDump() {
      try {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const frame = { v: 1, type: "trace.dump", last: 200 };
        attachTrace(frame, "send");
        ws.send(JSON.stringify(frame));
      } catch (_) {}
    }

    if (debugHideBtn) debugHideBtn.addEventListener("click", () => {
      debugVisible = false;
      traceVisible = false;
      _setDebugPanelVisible();
    });
    if (debugTraceDumpBtn) debugTraceDumpBtn.addEventListener("click", () => requestTraceDump());
    document.addEventListener("keydown", (ev) => {
      if (ev.ctrlKey && ev.shiftKey && (ev.key === "D" || ev.key === "d")) {
        ev.preventDefault();
        toggleDebugPanel();
      }
      if (ev.ctrlKey && ev.shiftKey && (ev.key === "T" || ev.key === "t")) {
        ev.preventDefault();
        toggleTracePanel();
      }
      if (ev.ctrlKey && ev.shiftKey && (ev.key === "Y" || ev.key === "y")) {
        ev.preventDefault();
        requestTraceDump();
      }
    });

    // --- Mobile drawer (Projects) ---
    const rightPane = document.getElementById("right");
    const mobileDrawer = document.getElementById("mobileDrawer");
    const mobileDrawerBackdrop = document.getElementById("mobileDrawerBackdrop");
    const closeDrawerBtn = document.getElementById("closeDrawerBtn");
    const drawerContent = document.getElementById("drawerContent");

    function isMobile() {
      return window.matchMedia && window.matchMedia("(max-width: 800px)").matches;
    }

    let _rightPaneHome = null;

    function openDrawer() {
      if (!isMobile() || !mobileDrawer || !mobileDrawerBackdrop || !drawerContent || !rightPane) return;
      if (!_rightPaneHome) _rightPaneHome = rightPane.parentElement;

      // Move the existing right pane into the drawer (no duplicate IDs)
      if (rightPane.parentElement !== drawerContent) {
        drawerContent.appendChild(rightPane);
        rightPane.style.display = "block";
        rightPane.style.height = "auto";
      }

      mobileDrawerBackdrop.style.display = "block";
      mobileDrawer.style.right = "0";
    }

    function closeDrawer() {
      if (!mobileDrawer || !mobileDrawerBackdrop) return;
      mobileDrawer.style.right = "-92%";
      mobileDrawerBackdrop.style.display = "none";

      // Move right pane back to its original place and hide it on mobile
      if (_rightPaneHome && rightPane && rightPane.parentElement) {
        _rightPaneHome.appendChild(rightPane);
        if (isMobile()) rightPane.style.display = "none";
      }
    }

    if (closeDrawerBtn) closeDrawerBtn.addEventListener("click", closeDrawer);
    if (mobileDrawerBackdrop) mobileDrawerBackdrop.addEventListener("click", closeDrawer);

    // --- Project dropdown (replaces drawer UX) ---
    const projectMenu = document.getElementById("projectMenu");
    const projectMenuBackdrop = document.getElementById("projectMenuBackdrop");
    // -------------------------------
    // Expert (hat) switching - UI ONLY
    // -------------------------------
    const EXPERTS = [
      {
        id: "default", label: "Default",
        accent: "#2563eb",

        // Slightly darker light mode so it’s clearly a surface
        lightBg: "#f2f2f2",
        lightElevated: "#f9f9f9",

        darkBg: "#050505",
        darkElevated: "#0a0a0a"
      },

      {
        id: "coding", label: "Coding",
        accent: "#16a34a",

        // +1 step contrast: clearer mode shift, still calm
        lightBg: "#e4f2e8",
        lightElevated: "#eff9f2",

        darkBg: "#02140b",        // slightly lighter than pure near-black
        darkElevated: "#062016"
      },
      {
        id: "health", label: "Health",
        accent: "#dc2626",

        // +1 step contrast: clearer mode shift, still calm
        lightBg: "#f7e3e3",
        lightElevated: "#fbeeee",

        darkBg: "#1a0606",
        darkElevated: "#240a0a"
      },
      {
        id: "therapist", label: "Therapist",
        accent: "#0ea5a3",

        // Calm teal, professional
        lightBg: "#e3f4f3",
        lightElevated: "#eef9f8",

        darkBg: "#041416",
        darkElevated: "#082024"
      },
      {
        id: "analysis", label: "Analysis",
        accent: "#d97706",

        // +1 step contrast: clearer mode shift, still calm
        lightBg: "#f2e4c8",
        lightElevated: "#f9efd9",

        darkBg: "#141006",
        darkElevated: "#1f1809"
      },
    ];

    function isCouplesUser() {
      const u = (window.__LENS0_AUTH_USER || "").trim().toLowerCase();
      return u.startsWith("couple_") || u.startsWith("couple ");
    }

    function expertStorageKey(projectName) {
      const u = (window.__LENS0_AUTH_USER || "guest").trim() || "guest";
      const p = (projectName || "default").trim() || "default";
      return `lens0-active-expert:${u}:${p}`;
    }

    function loadActiveExpert(projectName) {
      try {
        const v = (window.localStorage.getItem(expertStorageKey(projectName)) || "").trim();
        if (v === "writing") return "health";
        return v || "default";
      } catch (_) {
        return "default";
      }
    }

    function saveActiveExpert(id, projectName) {
      try { window.localStorage.setItem(expertStorageKey(projectName), id); } catch (_) {}
    }

    function projectForExpertStore() {
      return (currentProjectName || desiredProjectName || "default").trim() || "default";
    }

    function syncExpertForProject(projectName) {
      const p = (projectName || "default").trim() || "default";
      if (isCouplesUser() && p.toLowerCase() === "couples_therapy") {
        activeExpert = "therapist";
        saveActiveExpert(activeExpert, p);
      } else {
        activeExpert = loadActiveExpert(p);
      }
      applyExpertTheme(activeExpert);

      if (expertPill) {
        const ex = expertById(activeExpert);
        expertPill.textContent = ex.label + " ▾";
      }

      _lastAckedExpert = activeExpert;
    }

    function expertById(id) {
      return EXPERTS.find(x => x.id === id) || EXPERTS[0];
    }

    function applyExpertTheme(id) {
      const ex = expertById(id);
      const root = document.documentElement;
      const isDark = root.classList.contains("dark");

      // Accent
      root.style.setProperty("--accent", ex.accent);

      // Full UI palette (tinted by expert, influenced by dark/light)
      const bg = isDark ? ex.darkBg : ex.lightBg;
      const elevated = isDark ? ex.darkElevated : ex.lightElevated;

      root.style.setProperty("--bg", bg);
      root.style.setProperty("--bg-elevated", elevated);

      // Soft accent derives from accent in a mode-aware way (no hardcoded pastel)
      // (keeps “Coding” dark mode as deep green, light mode as pale green)
      root.style.setProperty("--accent-soft", isDark ? "rgba(22,163,74,0.18)" : "rgba(22,163,74,0.12)");
      if (ex.id === "default") {
        root.style.setProperty("--accent-soft", isDark ? "rgba(96,165,250,0.20)" : "rgba(37,99,235,0.10)");
      } else if (ex.id === "health") {
        root.style.setProperty("--accent-soft", isDark ? "rgba(220,38,38,0.18)" : "rgba(220,38,38,0.10)");
      } else if (ex.id === "therapist") {
        root.style.setProperty("--accent-soft", isDark ? "rgba(14,165,163,0.20)" : "rgba(14,165,163,0.10)");
      } else if (ex.id === "analysis") {
        root.style.setProperty("--accent-soft", isDark ? "rgba(217,119,6,0.18)" : "rgba(217,119,6,0.10)");
      }

      // Subtle borders that match the mode (and feel “inked” by the expert)
      root.style.setProperty("--border-subtle", isDark ? "rgba(255,255,255,0.10)" : "rgba(17,24,39,0.10)");

      // User bubble tint (since only user has bubble now)
      root.style.setProperty("--bg-chat-user", isDark ? "rgba(255,255,255,0.08)" : "rgba(17,24,39,0.06)");
      root.style.setProperty(
        "--bg-chat-system",
        isDark ? "rgba(255,255,255,0.08)" : "rgba(17,24,39,0.06)"
      );
    }

    // Initialize expert based on the last known project (best-effort; will be corrected on first project meta message)
    let activeExpert = loadActiveExpert(
      (window.localStorage.getItem("lens0-project") || "default").trim() || "default"
    );
    let _lastAckedExpert = activeExpert;

    // Apply immediately on load
    if (isCouplesUser()) activeExpert = "therapist";
    applyExpertTheme(activeExpert);

    const expertPill = document.getElementById("expertPill");
    const expertMenu = document.getElementById("expertMenu");

    function closeExpertMenu() {
      if (expertMenu) expertMenu.style.display = "none";
    }

    function openExpertMenu() {
      if (!expertMenu || !expertPill) return;

      expertMenu.innerHTML = "";
      expertMenu.style.display = "block";

      // position under the top bar, centered
      const rect = expertPill.getBoundingClientRect();
      expertMenu.style.position = "fixed";
      expertMenu.style.top = (rect.bottom + 10) + "px";
      expertMenu.style.left = "50%";
      expertMenu.style.transform = "translateX(-50%)";
      expertMenu.style.width = "min(260px, calc(100vw - 24px))";
      expertMenu.style.maxHeight = "min(360px, 50vh)";
      expertMenu.style.overflow = "auto";
      expertMenu.style.borderRadius = "14px";
      expertMenu.style.border = "1px solid var(--border-subtle)";
      expertMenu.style.background = "var(--bg-elevated)";
      expertMenu.style.boxShadow = "0 12px 30px rgba(0,0,0,0.18)";
      expertMenu.style.padding = "8px";
      expertMenu.style.zIndex = "10000";

      for (const ex of EXPERTS) {
        const b = document.createElement("button");
        b.type = "button";
        b.style.width = "100%";
        b.style.textAlign = "left";
        b.style.padding = "10px 12px";
        b.style.borderRadius = "12px";
        b.style.border = "1px solid transparent";
        b.style.background = (ex.id === activeExpert) ? "rgba(148,163,184,0.12)" : "transparent";
        b.style.color = "var(--text-main)";
        b.style.fontWeight = (ex.id === activeExpert) ? "800" : "650";
        b.textContent = ex.label;

        b.addEventListener("click", () => {
          const next = ex.id;
          if (next === activeExpert) {
            closeExpertMenu();
            return;
          }

          activeExpert = next;
          saveActiveExpert(activeExpert, projectForExpertStore());
          applyExpertTheme(activeExpert);
          try {
            if (window.UploadCenter && typeof window.UploadCenter.refresh === "function") {
              window.UploadCenter.refresh();
            }
          } catch (_) {}

          if (expertPill) expertPill.textContent = ex.label + " ▾";

          closeExpertMenu();

          // Ask the server for a contextual, tone-matched greeting on expert switch.
          try {
            if (ws && ws.readyState === WebSocket.OPEN) {
              const p = String(currentProjectName || desiredProjectName || "default").trim() || "default";
              const reason = `expert_switch:${ex.id}`;
              const now = Date.now();
              const k = `${p}|${reason}`;
              const last = __greetReqLastAt[k] || 0;
              if ((now - last) >= 4000) {
                __greetReqLastAt[k] = now;
                const frame = { v: 1, type: "greeting.request", project: p, reason };
                attachTrace(frame, "send");
                ws.send(JSON.stringify(frame));
              }
            }
          } catch (_) {}
          _lastAckedExpert = activeExpert;
        });

        expertMenu.appendChild(b);
      }
    }

    if (expertPill) {
      const ex = expertById(activeExpert);
      expertPill.textContent = ex.label + " ▾";

      expertPill.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (expertMenu && expertMenu.style.display === "block") closeExpertMenu();
        else openExpertMenu();
      });
    }

    document.addEventListener("click", (e) => {
      if (!expertMenu || expertMenu.style.display === "none") return;
      const t = e.target;
      if (t === expertPill || (expertMenu && expertMenu.contains(t))) return;
      closeExpertMenu();
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeExpertMenu();
    });

    function closeProjectMenu() {
      if (projectMenu) projectMenu.style.display = "none";
      if (projectMenuBackdrop) projectMenuBackdrop.style.display = "none";
    }

    async function openProjectMenu() {
      if (!projectMenu || !projectMenuBackdrop) return;

      projectMenu.innerHTML = `
        <div class="projectMenuTitle">Chats</div>
        <div class="projectMenuCreateRow">
          <button id="projectMenuNewChatBtn" type="button">New chat</button>
        </div>
        <button id="projectMenuDeleteBtn" class="projectMenuDangerBtn" type="button">Delete this chat</button>
      `;

      // Wire up create-new chat (server treats "switch project" as create-if-missing)
      setTimeout(() => {
        const btn = document.getElementById("projectMenuNewChatBtn");
        const delBtn = document.getElementById("projectMenuDeleteBtn");

        function doCreate() {
          createNewChat({ closeMenu: true });
        }
        async function doDelete() {
          const name = (currentProjectName || "").trim();
          if (!name || name.toLowerCase() === "default") {
            appendInfo("[WARN] Default chat cannot be deleted.");
            return;
          }

          const ok = window.confirm(`Delete chat "${name}"-\n\nThis permanently deletes all files, artifacts, and memory for this chat.`);
          if (!ok) return;

          closeProjectMenu();

          try {
            const res = await fetch(`${API_ORIGIN}/delete_project`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ project: name })
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || !data.ok) {
              appendInfo(`[ERROR] Delete failed: ${data.error || ("HTTP " + res.status)}`);
              return;
            }

            // After deletion: go to default
            if (ws && ws.readyState === WebSocket.OPEN) {
              // Use canonical WS frame (no user bubble).
              try {
                const frame = {
                  v: 1,
                  type: "chat.send",
                  text: "!switch project: default",
                  project: (currentProjectName || desiredProjectName || "default"),
                  active_expert: (activeExpert || "default"),
                  intent: {}
                };
                attachTrace(frame, "send");
                ws.send(JSON.stringify(frame));
              } catch (_) {}
            }

            appendChat(`Done - I deleted "${name}". I'll keep you in **default**.`, "assistant");
          } catch (e) {
            appendInfo("[ERROR] Delete failed.");
          }
        }

        if (delBtn) delBtn.addEventListener("click", doDelete);

        if (btn) btn.addEventListener("click", doCreate);
      }, 0);

      projectMenu.style.display = "block";
      projectMenuBackdrop.style.display = "block";

      try {
        const res = await fetch(`${API_ORIGIN}/list_projects`);
        if (!res.ok) {
          projectMenu.innerHTML += `<div class="muted" style="padding:8px;">Failed to load chats.</div>`;
          return;
        }
        const data = await res.json().catch(() => ({}));
        const items = (data && data.projects) ? data.projects : [];

        if (!items.length) {
          projectMenu.innerHTML += `<div class="muted" style="padding:8px;">(no chats)</div>`;
          return;
        }

        for (const item of items) {
          let name = "";
          let title = "";
          if (typeof item === "string") {
            name = item;
          } else if (item && typeof item === "object") {
            name = String(item.name || "").trim();
            title = String(item.title || "").trim();
          }
          if (!name) continue;
          if (title) projectTitleMap[name] = title;

          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "projectMenuItem" + (name === currentProjectName ? " current" : "");
          btn.innerHTML = `
            <span>${displayNameForProject(name)}</span>
            <span class="projectMenuMeta">${name === currentProjectName ? "Current" : ""}</span>
          `;

          btn.addEventListener("click", () => {
            if (!ws) {
              appendInfo("[WARN] Not connected; no WebSocket.");
              return;
            }
            if (ws.readyState !== WebSocket.OPEN) {
              appendInfo("[WARN] Not connected; socket not open.");
              return;
            }

            closeProjectMenu();

            // Arm continuity for THIS explicit target
            noteProjectSwitch("user", name);
            desiredProjectName = name;

            // Immediately swap the visible thread (ChatGPT-style) before the server finishes switching.
            // If we have cached history, it will show instantly; otherwise the chat will be empty until new messages arrive.
            try { ensureThreadVisibleForProject(name); } catch (_) {}

            // Switch by name (never index)
            // Use canonical WS frame (no user bubble).
            try {
              const frame = {
                v: 1,
                type: "chat.send",
                text: "!switch project: " + name,
                project: (currentProjectName || desiredProjectName || "default"),
                active_expert: (activeExpert || "default"),
                intent: {}
              };
              attachTrace(frame, "send");
              ws.send(JSON.stringify(frame));
            } catch (_) {}

            showThinking();
          });

          projectMenu.appendChild(btn);
        }
      } catch (_) {
        projectMenu.innerHTML += `<div class="muted" style="padding:8px;">Failed to load chats.</div>`;
      }
    }

    if (projectNamePill) {
      projectNamePill.style.cursor = "pointer";
      projectNamePill.title = "Tap to switch chat";
      projectNamePill.addEventListener("click", () => {
        // Toggle
        if (projectMenu && projectMenu.style.display === "block") {
          closeProjectMenu();
        } else {
          openProjectMenu();
        }
      });
    }

    if (projectMenuBackdrop) {
      projectMenuBackdrop.addEventListener("click", closeProjectMenu);
    }

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeProjectMenu();
    });

    window.addEventListener("resize", () => {
      // Always close transient UI on resize
      closeProjectMenu();
      if (!isMobile()) closeDrawer();
    });

    function nowTs() {
      // Always display timestamps in Oklahoma time (America/Chicago), not UTC.
      const d = new Date();
      try {
        return new Intl.DateTimeFormat("en-US", {
          timeZone: "America/Chicago",
          hour12: false,
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        }).format(d);
      } catch (_) {
        // Fallback: local time if Intl/timeZone isn't supported
        const hh = String(d.getHours()).padStart(2, "0");
        const mm = String(d.getMinutes()).padStart(2, "0");
        const ss = String(d.getSeconds()).padStart(2, "0");
        return `${hh}:${mm}:${ss}`;
      }
    }
    // iOS Safari clipboard workaround:
    // navigator.clipboard.writeText() re-encodes text when pasting into web inputs.
    function isIOS() {
      const ua = navigator.userAgent || "";
      const iOSDevice = /iPad|iPhone|iPod/.test(ua);

      // iPadOS 13+ often reports as "MacIntel" but has touch points.
      const iPadOS13Plus =
        (navigator.platform === "MacIntel" &&
         typeof navigator.maxTouchPoints === "number" &&
         navigator.maxTouchPoints > 1);

      return (iOSDevice || iPadOS13Plus) && !window.MSStream;
    }

    function copyTextIOSSafe(text) {
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.top = "-9999px";
      document.body.appendChild(ta);

      ta.focus();
      ta.select();
      try {
        document.execCommand("copy");
      } finally {
        document.body.removeChild(ta);
      }
    }

    // Visible build stamp so you can instantly tell whether mobile is running the new UI or a cached one.
    const UI_BUILD_STAMP = "2025-12-20__BUILD_01";

    // ---------------------------------------------------------------------
    // UI authority flags (default: backend owns behavior; UI is a dumb shell)
    // ---------------------------------------------------------------------
    const ENABLE_UI_PROMPT_INJECTION = false;  // when false: do NOT append [SCOPE]/[DELIVERABLE] wrappers
    const ENABLE_UI_SANITIZE = false;          // when false: do NOT rewrite/remove assistant content

    // Normalize possibly-encoded text coming from the server or clipboard.
    // Handles:
    // - legacy %uXXXX escapes (escape()-style)
    // - standard %XX URL encoding (bounded multi-pass; tolerates stray '%' like "55%")
    function normalizeText(input, maxPasses = 6) {
      if (input == null) return "";
      let s = String(input);

      // 1) Decode %uXXXX (legacy escape()) sequences
      // Example: "%u2019" => "’"
      s = s.replace(/%u([0-9A-Fa-f]{4})/g, (_, hex) => {
        try {
          return String.fromCharCode(parseInt(hex, 16));
        } catch {
          return "%u" + hex;
        }
      });

      // 2) Decode %XX sequences, safely (won't throw on stray '%')
      function safePercentDecode(str) {
        const plusFixed = str.replace(/\+/g, " ");
        const pctFixed = plusFixed.replace(/%(?![0-9A-Fa-f]{2})/g, "%25");
        try {
          return decodeURIComponent(pctFixed);
        } catch {
          return str;
        }
      }

      for (let i = 0; i < maxPasses; i++) {
        if (!(s.includes("%") || /%[0-9A-Fa-f]{2}/.test(s))) break;
        const next = safePercentDecode(s);
        if (next === s) break;
        s = next;
      }

      return s;
    }
    function sanitizeAssistantMessage(raw) {
      // Backend-authoritative mode: never rewrite assistant output.
      if (!ENABLE_UI_SANITIZE) {
        return (raw == null) ? "" : String(raw);
      }

      let msg = (raw == null) ? "" : String(raw);

      // 1) Strip common “system narration” / orchestration lines (keep user-facing content)
      // Keep this conservative: only remove lines we KNOW are boilerplate.
      const dropExact = new Set([
        "Tell me what you want to do next with this file, or ask for a patch to change it.",
      ]);

      const dropStartsWith = [
        "PATCH (anchor-based) - apply manually, or use the unified diff below",
        "Anchor patch instructions (copy/paste as-is):",
        "Unified diff patch (git apply -p1):",
      ];

      msg = msg
        .split(/\r?\n/)
        .filter((ln) => {
          const s = (ln || "").trim();
          if (!s) return true;

          if (dropExact.has(s)) return false;
          for (const p of dropStartsWith) {
            if (s.startsWith(p)) return false;
          }
          return true;
        })
        .join("\n");

      // 2) Tone swaps (safe + minimal)
      msg = msg.replace(/\bSuggested next\b/gi, "Next");
      msg = msg.replace(/\bTell me what you want to do next\b/gi, "Next");

      // Remove “User …” narration if it appears at the start of a line.
      msg = msg.replace(/(^|\n)\s*User\s+/g, "$1");

      const out = msg.trimEnd();

      // Safety: never return empty if we removed everything.
      // Better to show raw than to look like the assistant "didn't respond".
      if (!out) return (raw == null) ? "" : String(raw);

      return out;
    }
    // HTML escape helper (used by UploadCenter menu rendering)
    function escapeHtml(v) {
      const s = (v == null) ? "" : String(v);
      return s
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    // --- Rich rendering helpers (UI-only formatting) ---
    function isImagePathLike(s) {
      const t = (s || "").toLowerCase();
      return t.endsWith(".png") || t.endsWith(".jpg") || t.endsWith(".jpeg") || t.endsWith(".webp") || t.endsWith(".gif");
    }

    function hrefForToken(token) {
      const tok = (token || "").trim();
      if (!tok) return "";
      return tok.startsWith("/file-path=") ? tok : ("/file-path=" + tok);
    }
    // Display helper: show only the filename, keep the full path in title tooltips elsewhere.
    function prettyFileName(tokenOrHref) {
      let s = (tokenOrHref == null) ? "" : String(tokenOrHref).trim();
      if (!s) return "";

      // Strip /file-path=
      if (s.startsWith("/file-path=")) s = s.slice("/file-path=".length);

      // Decode percent escapes safely using the existing normalizer
      s = normalizeText(s, 2);

      // Drop querystring (if any)
      s = s.split("-")[0];

      // Return last path segment
      const parts = s.split("/").filter(Boolean);
      return parts.length ? parts[parts.length - 1] : s;
    }

    function appendTextWithFileLinks(parent, rawText) {
      const s = (rawText == null) ? "" : String(rawText);

      // Linkify:
      // 1) Internal served files: /file-path=...
      // 2) Raw project paths: projects/<user>/<project>/<...>  → /file-path=<that path>
      // 3) External URLs: https://... or http://...
      //
      // NOTE: We intentionally do NOT fetch external metadata/images (no previews).
      // We only make them clickable (best-of-both-worlds: safe + useful).
      const re = /((\/file\-path=[^\s]+)|(projects\/[A-Za-z0-9._-]+\/[A-Za-z0-9._-]+\/[^\s]+)|(https?:\/\/[^\s\)\]\}>,]+))/g;

      let last = 0;
      let m;
      while ((m = re.exec(s)) !== null) {
        const before = s.slice(last, m.index);
        if (before) parent.appendChild(document.createTextNode(before));

        const token = m[1];

        // Determine href + display label
        let href = "";
        let label = "";

        if (token.startsWith("/file-path=")) {
          href = token;
          label = prettyFileName(token);
        } else if (token.startsWith("projects/")) {
          href = "/file-path=" + token;
          label = prettyFileName(token);
        } else if (token.startsWith("http://") || token.startsWith("https://")) {
          href = token;
          // Keep external URLs readable but not ridiculous.
          // Show host + last path segment if possible; fallback to full token.
          try {
            const u = new URL(token);
            const parts = (u.pathname || "").split("/").filter(Boolean);
            const tail = parts.length ? parts[parts.length - 1] : "";
            label = tail ? (u.hostname + "/" + tail) : u.hostname;
          } catch (_) {
            label = token;
          }
        }

        if (!href) {
          // Shouldn't happen, but fail safe.
          parent.appendChild(document.createTextNode(token));
          last = m.index + token.length;
          continue;
        }

        const a = document.createElement("a");
        a.href = href;
        a.target = "_blank";
        a.rel = "noopener";
        a.textContent = label || token;
        a.title = token; // keep full original text for long-press/hover
        parent.appendChild(a);

        // Only show inline previews for INTERNAL served image files (never external URLs).
        if ((token.startsWith("/file-path=") || token.startsWith("projects/")) && (isImagePathLike(token) || isImagePathLike(href))) {
          const wrap = document.createElement("div");
          wrap.className = "file-preview";

          const img = document.createElement("img");
          img.loading = "lazy";
          img.src = href;

          const cap = document.createElement("div");
          cap.className = "cap";
          cap.textContent = prettyFileName(token);
          cap.title = token;

          wrap.appendChild(img);
          wrap.appendChild(cap);
          parent.appendChild(wrap);
        }

        last = m.index + token.length;
      }

      const after = s.slice(last);
      if (after) parent.appendChild(document.createTextNode(after));
    }

    // Inline formatting: **bold**, `code`, and /file-path=... links inside all text.
    function appendInlineFormatted(parent, rawText) {
      const s = (rawText == null) ? "" : String(rawText);

      // We parse a minimal subset:
      // - **bold**
      // - `code`
      // Everything else is plain text, but we still linkify /file-path=... in plain segments.
      let i = 0;

      function appendPlainSegment(seg, into) {
        if (!seg) return;
        appendTextWithFileLinks(into, seg);
      }

      while (i < s.length) {
        const boldIdx = s.indexOf("**", i);
        const codeIdx = s.indexOf("`", i);

        let nextIdx = -1;
        let mode = null;

        if (boldIdx !== -1 && (codeIdx === -1 || boldIdx < codeIdx)) {
          nextIdx = boldIdx;
          mode = "bold";
        } else if (codeIdx !== -1) {
          nextIdx = codeIdx;
          mode = "code";
        }

        if (nextIdx === -1) {
          appendPlainSegment(s.slice(i), parent);
          break;
        }

        appendPlainSegment(s.slice(i, nextIdx), parent);

        if (mode === "bold") {
          const end = s.indexOf("**", nextIdx + 2);
          if (end === -1) {
            appendPlainSegment(s.slice(nextIdx), parent);
            break;
          }
          const content = s.slice(nextIdx + 2, end);
          const strong = document.createElement("strong");
          appendPlainSegment(content, strong);
          parent.appendChild(strong);
          i = end + 2;
          continue;
        }

        if (mode === "code") {
          const end = s.indexOf("`", nextIdx + 1);
          if (end === -1) {
            appendPlainSegment(s.slice(nextIdx), parent);
            break;
          }
          const content = s.slice(nextIdx + 1, end).trim();

          // If inline-code looks like a repo/file path, make it clickable.
          const looksLikePath =
            content.startsWith("/file-path=") ||
            content.startsWith("projects/");

          if (looksLikePath) {
            const href = content.startsWith("/file-path=")
              ? content
              : ("/file-path=" + content);

            const a = document.createElement("a");
            a.className = "code-link";
            a.href = href;
            a.target = "_blank";
            a.rel = "noopener";

            const code = document.createElement("code");
            code.textContent = prettyFileName(content);
            code.title = content;
            a.appendChild(code);

            parent.appendChild(a);
          } else {
            const code = document.createElement("code");
            code.textContent = content;
            parent.appendChild(code);
          }

          i = end + 1;
          continue;
        }
      }
    }

    function renderResumeCard(container, lines, contextText) {
      // Parse key/values once so we can build a guide-style layout deterministically.

      const items = [];
      const parsed = {};

      function sanitizeResumeValue(key, value) {
        let v = (value || "").trim();
        if (!v) return v;

        // Remove internal orchestration phrasing (keep meaning, lose “agent instructions” tone)
        // Examples:
        // - "Ask the user to confirm ..." -> "Confirm ..."
        // - "Clarify whether the user is asking ..." -> "Clarify whether you mean ..."
        // - "Have user confirm ..." -> "Confirm ..."
        v = v.replace(/^Ask the user to\s+/i, "");
        v = v.replace(/^Have user\s+/i, "");
        v = v.replace(/^Have the user\s+/i, "");
        v = v.replace(/^Clarify whether the user\s+/i, "Clarify whether you ");
        v = v.replace(/^Confirm it loads correctly and share\s+/i, "Confirm it loads correctly, then share ");

        // Light cleanup: "the user" -> "you" for a human-facing UI
        v = v.replace(/\bthe user\b/gi, "you");
        // More “professional guide” tone: remove internal narrator (“User ...”)
        v = v.replace(/^User\s+/i, "");
        v = v.replace(/^opens\s+/i, "Open ");
        v = v.replace(/^open\s+the\s+newly\s+generated\s+/i, "Open the ");
        v = v.replace(/\bprints it or saves it as a pdf\b/i, "print it (or save as PDF)");
        v = v.replace(/^User\s+opens\s+/i, "Open ");
        v = v.replace(/^User\s+confirms\s+/i, "Confirm ");

        // Only apply to these keys (don’t mess with Memory/Open)
        if (key === "Where we are" || key === "Next" || key === "Then") return v;
        return (value || "").trim();
      }

      function put(k, v) {
        if (!k) return;
        const vv = sanitizeResumeValue(k, v || "");
        parsed[k] = vv;
        items.push([k, vv]);
      }

      for (const raw of lines) {
        const line = (raw || "").trim();
        if (!line) continue;

        const cleaned = line.startsWith("- ") ? line.slice(2) : line;
        const idx = cleaned.indexOf(":");
        if (idx === -1) {
          put("Note", cleaned);
          continue;
        }

        const kRaw = cleaned.slice(0, idx).trim();
        const v = cleaned.slice(idx + 1).trim();
        if (!kRaw) continue;

        const keyMap = {
          "Where we are": "Where we are",
          "Open": "Open",
          "Suggested next": "Next",
          "Then": "Then",
          "Memory": "Memory",
        };

        const k = keyMap[kRaw] || kRaw;
        put(k, v);
      }
      function isImageLikePath(v) {
        const s = (v || "").toLowerCase();
        return s.endsWith(".png") || s.endsWith(".jpg") || s.endsWith(".jpeg") || s.endsWith(".webp") || s.endsWith(".gif");
      }

      function isPrimaryDocPath(v) {
        const s = (v || "").toLowerCase();
        // treat these as “resume-worthy” primary documents
        return s.endsWith(".html") || s.endsWith(".pdf") || s.endsWith(".docx") || s.endsWith(".xlsx") || s.endsWith(".md");
      }
      // If Open points to an image, it’s not “resume-worthy” - drop it.
      if (parsed["Open"] && isImageLikePath(parsed["Open"]) && !isPrimaryDocPath(parsed["Open"])) {
        delete parsed["Open"];
        // also remove from items array so it doesn't show anywhere
        for (let idx = items.length - 1; idx >= 0; idx--) {
          if (items[idx] && items[idx][0] === "Open") items.splice(idx, 1);
        }
      }
      function isPrimaryDocHref(href) {
        const h = (href || "").toLowerCase();
        return h.endsWith(".html") || h.endsWith(".pdf") || h.endsWith(".docx") || h.endsWith(".xlsx") || h.endsWith(".md");
      }

      function extractAllFileRefs(s) {
        const v = (s || "");
        const re = /((\/file\-path=[^\s\)\]\}>,]+)|(projects\/[A-Za-z0-9._-]+\/[A-Za-z0-9._-]+\/[^\s\)\]\}>,]+))/g;
        const out = [];
        let m;
        while ((m = re.exec(v)) !== null) {
          const token = (m[1] || "").trim();
          if (!token) continue;
          const href = token.startsWith("/file-path=") ? token : ("/file-path=" + token);
          out.push({ token, href });
        }
        return out;
      }

      function pickPrimaryDoc(parsed) {
        // 1) Prefer Open if it’s a primary doc
        const o = (parsed["Open"] || "").trim();
        if (o) {
          const href = o.startsWith("/file-path=") ? o : ("/file-path=" + o);
          if (isPrimaryDocHref(href)) return { token: o, href };
        }

        // 2) Scan Next/Where/Then for first primary doc
        for (const k of ["Next", "Where we are", "Then"]) {
          const refs = extractAllFileRefs(parsed[k] || "");
          for (const r of refs) {
            if (isPrimaryDocHref(r.href)) return r;
          }
        }

        // 3) Scan the surrounding assistant message text (contextText)
        const ctxRefs = extractAllFileRefs(contextText || "");
        for (const r of ctxRefs) {
          if (isPrimaryDocHref(r.href)) return r;
        }

        return null;
      }

      // Status header removed: redundant with "Next action"

      function extractFirstFileRef(s) {
        const v = (s || "");
        // Match either /file-path=... OR raw projects/<user>/<project>/...
        const re = /((\/file\-path=[^\s\)\]\}>,]+)|(projects\/[A-Za-z0-9._-]+\/[A-Za-z0-9._-]+\/[^\s\)\]\}>,]+))/;
        const m = v.match(re);
        if (!m) return null;

        const token = (m[1] || "").trim();
        if (!token) return null;

        const href = token.startsWith("/file-path=") ? token : ("/file-path=" + token);
        return { token, href };
      }

      // Next action callout (dominant): treat this as THE action, not “suggested”.
      if (parsed["Next"]) {
        // Prefer a real primary doc even if Next text contains no path (travel project case).
        const primary = pickPrimaryDoc(parsed);

        const targetHref = primary && primary.href ? primary.href : null;
        const targetLabel = primary && primary.token ? primary.token : null;

        const nextBox = document.createElement("div");
        nextBox.className = "resume-next" + (targetHref ? " clickable" : "");
        if (targetHref) nextBox.title = "Tap to open";

        const label = document.createElement("div");
        label.className = "label";
        label.textContent = "Next action";

        const text = document.createElement("div");
        text.className = "text";

        // If we can resolve a primary deliverable doc, force the Next Action to be direct + user-facing.
        if (targetHref && targetLabel) {
          text.textContent = "Tap to open and review " + prettyFileName(targetLabel) + ". Then reply with what to change.";
        } else {
          appendInlineFormatted(text, parsed["Next"]);
        }

        nextBox.appendChild(label);
        nextBox.appendChild(text);

        // If we know the primary doc, show it and make the whole pill open it.
        if (targetHref && targetLabel) {
          const linkRow = document.createElement("div");
          linkRow.className = "resume-next-link";

          const a = document.createElement("a");
          a.className = "code-link";
          a.href = targetHref;
          a.rel = "noopener";

          const code = document.createElement("code");
          code.textContent = prettyFileName(targetLabel);
          code.title = targetLabel;
          a.appendChild(code);

          linkRow.appendChild(a);
          nextBox.appendChild(linkRow);

          // Whole-pill tap opens in a NEW tab (keeps the app page alive).
          // Add touchend for iOS reliability.
          const go = (e) => {
            const t = e && e.target;
            if (t && (t.tagName === "A" || (t.closest && t.closest("a")))) return;

            try {
              window.open(targetHref, "_blank", "noopener");
            } catch (_) {
              // Fallback: create a real anchor click (still user-initiated)
              const tmp = document.createElement("a");
              tmp.href = targetHref;
              tmp.target = "_blank";
              tmp.rel = "noopener";
              document.body.appendChild(tmp);
              tmp.click();
              tmp.remove();
            }
          };
          nextBox.addEventListener("click", go);
          nextBox.addEventListener("touchend", go, { passive: true });
        }

        container.appendChild(nextBox);
      }

      // Resume card (details)
      const card = document.createElement("div");
      card.className = "resume-card";

      const titleRow = document.createElement("div");
      titleRow.className = "resume-title";

      const title = document.createElement("strong");
      title.textContent = "Resume";

      titleRow.appendChild(title);
      card.appendChild(titleRow);

      // Optional Open row: ONLY show if Next Action does NOT already open a primary deliverable.
      if (parsed["Open"] && !(parsed["Next"] && pickPrimaryDoc(parsed))) {
        const openRow = document.createElement("div");
        openRow.className = "resume-openrow";

        const hrefText = parsed["Open"].trim();
        const href = hrefText.startsWith("/file-path=") ? hrefText : ("/file-path=" + hrefText);

        const a = document.createElement("a");
        a.className = "resume-openbtn";
        a.href = href;
        a.target = "_blank";
        a.rel = "noopener";
        a.textContent = "Open";

        // Separate line: clickable code-style path (won’t distort the Open button)
        const pathLine = document.createElement("div");
        pathLine.style.marginTop = "6px";

        const pathA = document.createElement("a");
        pathA.className = "code-link";
        pathA.href = href;
        pathA.target = "_blank";
        pathA.rel = "noopener";

        const code = document.createElement("code");
        code.textContent = prettyFileName(hrefText);
        code.title = hrefText;
        pathA.appendChild(code);

        pathLine.appendChild(pathA);

        openRow.appendChild(a);
        card.appendChild(openRow);
        card.appendChild(pathLine);
      }

      const kv = document.createElement("div");
      kv.className = "resume-kv";

      function addKV(k, v) {
        // Skip Open + Next in the KV grid (Open is a button row; Next is already highlighted)
        if (k === "Open" || k === "Next") return;

        const kk = document.createElement("div");
        kk.className = "resume-k";
        kk.textContent = k;

        const vv = document.createElement("div");
        vv.className = "resume-v";
        appendInlineFormatted(vv, v);

        kv.appendChild(kk);
        kv.appendChild(vv);
      }

      for (const [k, v] of items) addKV(k, v);

      card.appendChild(kv);

      container.appendChild(card);
    }
    // Used by renderStructuredMessage() and others.
    function extractFirstFileRef(s) {
      const v = (s || "");
      // Match either /file-path=... OR raw projects/<user>/<project>/...
      const re = /((\/file\-path=[^\s\)\]\}>,]+)|(projects\/[A-Za-z0-9._-]+\/[A-Za-z0-9._-]+\/[^\s\)\]\}>,]+))/;
      const m = v.match(re);
      if (!m) return null;

      const token = (m[1] || "").trim();
      if (!token) return null;

      const href = token.startsWith("/file-path=") ? token : ("/file-path=" + token);
      return { token, href };
    }


    function renderStructuredMessage(container, rawText) {
      const text = (rawText == null) ? "" : String(rawText);
      const lines = text.split(/\r?\n/);

      // ------------------------------------------------------------
      // Inline web image rendering (bounded, deterministic)
      //
      // If the server emits markdown image lines like:
      //   ![caption](https://...)
      // optionally followed by:
      //   Source: https://...
      //
      // Render up to 3 images inline. This avoids dumping URL lists.
      // ------------------------------------------------------------
      try {
        let shown = 0;

        for (let i = 0; i < lines.length && shown < 3; i++) {
          const ln = String(lines[i] || "").trim();

          // Optional legacy header line: ignore if present
          if (/^IMAGE_RESULTS\b/i.test(ln)) continue;

          const m = ln.match(/^!\[([^\]]*)\]\((https?:\/\/[^\s\)]+)\)\s*$/);
          if (!m) continue;

          const capText = (m[1] || "").trim();
          const imgUrl = (m[2] || "").trim();
          if (!imgUrl) continue;

          const wrap = document.createElement("div");
          wrap.className = "file-preview";

          const img = document.createElement("img");
          img.loading = "lazy";
          img.src = imgUrl;
          wrap.appendChild(img);

          const cap = document.createElement("div");
          cap.className = "cap";

          // Next line may be "Source: https://..."
          let sourceUrl = "";
          try {
            const nxt = String(lines[i + 1] || "").trim();
            const sm = nxt.match(/^Source:\s*(https?:\/\/\S+)\s*$/i);
            if (sm && sm[1]) sourceUrl = sm[1].trim();
          } catch (_) {}

          if (sourceUrl) {
            // Caption as "caption - source"
            const a = document.createElement("a");
            a.href = sourceUrl;
            a.target = "_blank";
            a.rel = "noopener";
            a.textContent = capText ? capText : "Source";
            cap.appendChild(a);
          } else {
            cap.textContent = capText || "Image";
          }

          wrap.appendChild(cap);
          container.appendChild(wrap);

          shown += 1;
        }

        // If we rendered any images, do NOT fall through and also render raw URL text.
        if (shown > 0) return;
      } catch (_) {}

      // Detect Resume block anywhere in the message (not just first line)
      const resumeIndex = lines.findIndex(
        l => (l || "").trim() === "Resume:"
      );

      if (resumeIndex !== -1) {
        // Render anything before Resume normally
        if (resumeIndex > 0) {
          // In Resume-mode, drop the noisy system-preface lines (Project/Goal)
          // so the user sees ONE clean action path.
          const beforeLines = lines.slice(0, resumeIndex)
            .filter(l => {
              const t = String(l || "").trim();
              if (!t) return false;

              // Drop "Project: X Goal: Y" and similar single-line headers
              if (/^Project:\s+/i.test(t) && /\bGoal:\s+/i.test(t)) return false;

              // Drop standalone "Project:" or "Goal:" headers (these are already shown elsewhere in UI)
              if (/^Project:\s+/i.test(t)) return false;
              if (/^Goal:\s+/i.test(t)) return false;

              return true;
            });

          const before = beforeLines.join("\n").trim();
          if (before) {
            const pre = document.createElement("p");
            appendTextWithFileLinks(pre, before);
            container.appendChild(pre);
          }
        }

        // Render Resume card from lines after "Resume:"
        // Also pass message context so Next Action can resolve the primary doc even if Next has no path.
        const after = lines.slice(resumeIndex + 1);
        const beforeText = (resumeIndex > 0) ? lines.slice(0, resumeIndex).join("\n") : "";
        const ctx = (beforeText + "\n" + text).trim();
        renderResumeCard(container, after, ctx);
        return;
      }

      // Structure:
      // - "# " => h3, "## " => h4
      // ? "Title:" (short line ending in colon) => h4  (heuristic)
      // - "- " bullets => ul
      // - "1." / "1)" => ol
      // - everything else => paragraphs
      //
      // Inline formatting supported everywhere:
      // - **bold**
      // - `code`
      // - /file-path=... links
      let i = 0;
      while (i < lines.length) {
        // Fenced code blocks: preserve formatting exactly.
        // Example:
        // ```python
        // def x():
        //     pass
        // ```
        if ((lines[i] || "").trim().startsWith("```")) {
          const fenceLine = (lines[i] || "").trim();
          const lang = fenceLine.slice(3).trim(); // may be ""
          i += 1;

          const buf = [];
          while (i < lines.length) {
            const cur = (lines[i] == null) ? "" : String(lines[i]);
            if (cur.trim().startsWith("```")) {
              i += 1; // consume closing fence
              break;
            }
            buf.push(cur);
            i += 1;
          }

          const pre = document.createElement("pre");
          const code = document.createElement("code");
          if (lang) code.setAttribute("data-lang", lang);
          code.textContent = buf.join("\n");
          pre.appendChild(code);
          container.appendChild(pre);
          continue;
        }

        const line = lines[i];

        // Blank line => paragraph break
        if (!line || !line.trim()) {
          i += 1;
          continue;
        }

        const trimmed = line.trim();
        // Message-body action affordances (but never inside Resume cards - Resume renderer owns that UI)
        if (!container.closest(".resume-card")) {
          // Special-case: "Open: /file-path=..." should look like a clear action button
          if (/^Open:\s+/i.test(trimmed)) {
            const after = trimmed.replace(/^Open:\s+/i, "").trim();
            const ref = extractFirstFileRef(after) || extractFirstFileRef(trimmed);
            if (ref && ref.href) {
              const row = document.createElement("div");
              row.className = "resume-openrow";

              const a = document.createElement("a");
              a.className = "resume-openbtn";
              a.href = ref.href;
              a.target = "_blank";
              a.rel = "noopener";
              a.textContent = "Open";

              const pathLine = document.createElement("div");
              pathLine.style.marginTop = "6px";

              const pathA = document.createElement("a");
              pathA.className = "code-link";
              pathA.href = ref.href;
              pathA.target = "_blank";
              pathA.rel = "noopener";

              const code = document.createElement("code");
              code.textContent = ref.token || after;
              pathA.appendChild(code);

              pathLine.appendChild(pathA);

              row.appendChild(a);
              container.appendChild(row);
              container.appendChild(pathLine);

              i += 1;
              continue;
            }
          }

          // Special-case: "Project Pulse:" line becomes a header
          if (/^Project Pulse\b/i.test(trimmed) && trimmed.endsWith(":")) {
            const h = document.createElement("h3");
            appendInlineFormatted(h, trimmed.slice(0, -1).trim());
            container.appendChild(h);
            i += 1;
            continue;
          }
        }

        // Inline label formatting: "Project Pulse: ...", "Next: 1) ... 2) ...", etc.
        // This makes typical assistant output look structured without requiring the model to emit markdown.
        {
          const m = trimmed.match(/^([A-Za-z][A-Za-z0-9 _-]{0,32}):\s+(.+)$/);
          if (m && !trimmed.startsWith("/file-path=") && !trimmed.startsWith("http://") && !trimmed.startsWith("https://")) {
            const label = (m[1] || "").trim();
            const rest = (m[2] || "").trim();

            const isBig = label.toLowerCase() === "project pulse";
            const h = document.createElement(isBig ? "h3" : "h4");
            appendInlineFormatted(h, label);
            container.appendChild(h);

            // If rest contains "1) ... 2) ...", convert to ordered list
            if (/(\b1\)\s+).*(\b2\)\s+)/.test(rest)) {
              const parts = rest.split(/\s+(-=\d+\)\s+)/).filter(Boolean);
              const ol = document.createElement("ol");
              for (const part of parts) {
                const li = document.createElement("li");
                appendInlineFormatted(li, part.replace(/^\d+\)\s+/, ""));
                ol.appendChild(li);
              }
              container.appendChild(ol);
            } else {
              const p = document.createElement("p");
              appendInlineFormatted(p, rest);
              container.appendChild(p);
            }

            i += 1;
            continue;
          }
        }


        // Headings (explicit markdown)
        if (trimmed.startsWith("# ")) {
          const h = document.createElement("h3");
          appendInlineFormatted(h, trimmed.slice(2).trim());
          container.appendChild(h);
          i += 1;
          continue;
        }
        if (trimmed.startsWith("## ")) {
          const h = document.createElement("h4");
          appendInlineFormatted(h, trimmed.slice(3).trim());
          container.appendChild(h);
          i += 1;
          continue;
        }

        // Heuristic subheading: short "Something:" lines become h4
        // Avoid treating "/file-path=..." or long sentences as headings.
        if (
          trimmed.endsWith(":") &&
          trimmed.length <= 54 &&
          !trimmed.startsWith("- ") &&
          !trimmed.includes("/file-path=") &&
          !trimmed.includes("http://") &&
          !trimmed.includes("https://")
        ) {
          const h = document.createElement("h4");
          appendInlineFormatted(h, trimmed.slice(0, -1).trim());
          container.appendChild(h);
          i += 1;
          continue;
        }
        // Ordered list block: "1." or "1)" etc
        if (/^\d+[\.\)]\s+/.test(trimmed)) {
          const ol = document.createElement("ol");
          while (i < lines.length) {
            const t = (lines[i] || "").trim();
            if (!/^\d+[\.\)]\s+/.test(t)) break;
            const li = document.createElement("li");
            appendInlineFormatted(li, t.replace(/^\d+[\.\)]\s+/, ""));
            ol.appendChild(li);
            i += 1;
          }
          container.appendChild(ol);
          continue;
        }

        // Bullet list block
        if (trimmed.startsWith("- ")) {
          const ul = document.createElement("ul");
          while (i < lines.length) {
            const t = (lines[i] || "").trim();
            if (!t.startsWith("- ")) break;
            const li = document.createElement("li");
            appendInlineFormatted(li, t.slice(2));
            ul.appendChild(li);
            i += 1;
          }
          container.appendChild(ul);
          continue;
        }

        // Paragraph (collect until blank line)
        const p = document.createElement("p");
        let buf = [];
        while (i < lines.length) {
          const t = lines[i];
          if (!t || !t.trim()) break;

          const tt = t.trim();
          // stop before a new structural block
          if (tt.startsWith("# ") || tt.startsWith("## ") || tt.startsWith("- ")) break;

          buf.push(t);
          i += 1;
        }
        appendInlineFormatted(p, buf.join("\n"));
        container.appendChild(p);
      }
    }
    // --- Thread continuity: store last REAL chat per project (never Pulse/Resume, never commands) ---
    // This MUST be project-specific (no bleed across projects).
    const __lastRealByProject = Object.create(null);        // last real chat (user or assistant)
    const __lastAssistantByProject = Object.create(null);   // last real assistant answer (preferred continuity)

    // --- Thread history: full per-project conversation (UI-only; NEVER sent to model) ---
    // Stored as an array of { role, ts, text }. Replay does NOT touch "last real chat" caches.
    const __threadByProject = Object.create(null);

    function threadStorageKey(projectName) {
      const u = (window.__LENS0_AUTH_USER || "guest").trim() || "guest";
      const p = (projectName || "default").trim() || "default";
      return `lens0-thread-v1:${u}:${p}`;
    }

    function getThreadObj(projectName) {
      const p = (projectName || "default").trim() || "default";
      if (!__threadByProject[p]) {
        __threadByProject[p] = { loaded: false, messages: [] };
      }
      return __threadByProject[p];
    }

    function loadThreadFromStorage(projectName) {
      const p = (projectName || "default").trim() || "default";
      const t = getThreadObj(p);
      if (t.loaded) return t;

      t.loaded = true;
      t.messages = [];

      try {
        const raw = window.localStorage.getItem(threadStorageKey(p));
        if (!raw) return t;

        const obj = JSON.parse(raw);
        const arr = (obj && Array.isArray(obj.messages)) ? obj.messages : [];
        const cleaned = [];

        for (const it of arr) {
          if (!it || typeof it !== "object") continue;
          const role = String(it.role || "").trim();
          const ts = String(it.ts || "").trim();
          const text = (it.text == null) ? "" : String(it.text);
          if (!text.trim()) continue;
          if (!(role === "user" || role === "assistant" || role === "info")) continue;
          cleaned.push({ role, ts, text });
        }

        // Keep bounded so storage can’t blow up forever.
        t.messages = cleaned.slice(-800);
      } catch (_) {}

      return t;
    }

    function saveThreadToStorage(projectName) {
      const p = (projectName || "default").trim() || "default";
      const t = getThreadObj(p);
      try {
        const payload = {
          v: 1,
          project: p,
          saved_at: Date.now(),
          messages: (t.messages || []).slice(-800)
        };
        window.localStorage.setItem(threadStorageKey(p), JSON.stringify(payload));
      } catch (_) {}
    }

    function clearChatUI() {
      try {
        if (logEl) logEl.innerHTML = "";
      } catch (_) {}
    }

    function replayThreadToUI(projectName) {
      const p = (projectName || "default").trim() || "default";
      const t = loadThreadFromStorage(p);

      clearChatUI();

      // Replay without affecting continuity caches or re-saving thread.
      for (const m of (t.messages || [])) {
        appendChat(m.text, m.role, { isReplay: true, ts: m.ts, project: p });
      }
    }

    function ensureThreadVisibleForProject(projectName) {
      const p = (projectName || "default").trim() || "default";
      const t = loadThreadFromStorage(p);

      // If we have anything, render it. Otherwise show empty thread (normal flow will fill it).
      if ((t.messages || []).length > 0) {
        replayThreadToUI(p);
      } else {
        clearChatUI();
      }
    }

    function threadPush(projectName, entry) {
      const p = (projectName || "default").trim() || "default";
      const t = loadThreadFromStorage(p);

      // Normalize + bound
      const role = String(entry.role || "").trim();
      const ts = String(entry.ts || "").trim();
      const text = (entry.text == null) ? "" : String(entry.text);

      if (!(role === "user" || role === "assistant" || role === "info")) return;
      if (!text.trim()) return;

      t.messages.push({ role, ts, text });
      if (t.messages.length > 800) t.messages = t.messages.slice(-800);

      // Persist lazily but reliably (cheap write)
      saveThreadToStorage(p);
    }


    function activeProjectForStorage() {
      // During early connect, currentProjectName may lag; fall back to desiredProjectName.
      return (currentProjectName || desiredProjectName || "default").trim() || "default";
    }

    function isActualChatText(t) {
      // -------------------------------------------------------------------
      // Greeting replacement (FOUNDATIONAL UI behavior)
      //
      // Goal:
      // - Greetings are ephemeral “banner-like” content, not durable chat.
      // - If we receive another greeting for the same project BEFORE the user
      //   sends any real message, we REPLACE the prior greeting bubble.
      //
      // Implementation:
      // - track last greeting bubble per project
      // - track last real user message time per project
      // -------------------------------------------------------------------    
      const s = (t == null) ? "" : String(t).trim();
      if (!s) return false;

      // Exclude UI/system continuity messages
      if (s.startsWith("Last message (") || s.startsWith("Last chat (") || s.startsWith("Last answer (")) return false;

      // Exclude project-control / command-style messages (these are not "actual chats")
      const low = s.toLowerCase();
      if (low.startsWith("switch project:")) return false;
      if (low === "list" || low === "plan" || low === "refresh state") return false;
      if (low.startsWith("mode:")) return false;
      if (low.startsWith("[search]")) return false;

      // Exclude goal-setting command lines (these are meta, not conversation)
      if (low.startsWith("goal:")) return false;

      // Greetings are ephemeral, not durable chat
      if (isGreetingLikeMessage(s)) return false;

      return true;
    }

    // Greeting replacement state (per project)
    const __lastGreetingBubbleByProject = Object.create(null); // project -> DOM node
    const __lastGreetingAtByProject = Object.create(null);     // project -> epoch ms
    const __lastUserMsgAtByProject = Object.create(null);      // project -> epoch ms

    // GLOBAL greeting replacement fallback:
    // During a project switch, currentProjectName can lag, so per-project buckets may miss.
    // This ensures repeated switch-greetings still replace even if project meta races.
    let __lastGreetingBubbleGlobal = null;
    let __lastGreetingAtGlobal = 0;
    let __lastUserMsgAtGlobal = 0;
    function isGreetingLikeMessage(text) {
      const s0 = (text == null) ? "" : String(text);
      const s = s0.trim();
      if (!s) return false;

      // Broad but deterministic: greetings start with "Good <daypart>".
      // Do NOT require punctuation; some greetings use em-dash, period, etc.
      if (/^Good\s+(morning|afternoon|evening|night)\b/i.test(s)) return true;
      if (/^Welcome back\b/i.test(s)) return true;

      // Common “pick up where we left off” style greetings
      if (/pick up where we left off/i.test(s)) return true;

      return false;
    }

    function appendChat(text, role, opts) {
      const o = (opts && typeof opts === "object") ? opts : {};
      const isReplay = !!o.isReplay;
      const pForMsg = (o.project || activeProjectForStorage() || "default").trim() || "default";

      // Greeting replacement:
      // If another greeting arrives before any real user message, replace the previous greeting bubble.
      // Use BOTH per-project buckets + a global fallback (project meta can lag during switching).
      try {
        const r0 = (role == null) ? "" : String(role);
        const t0 = (text == null) ? "" : String(text);

        // Treat both assistant + info as eligible (some server messages may be info-like)
        const isGreet = (r0 === "assistant" || r0 === "info") && isGreetingLikeMessage(t0);

        if (isGreet) {
          // 1) Global fallback replacement
          if (__lastGreetingBubbleGlobal && __lastGreetingAtGlobal && (__lastUserMsgAtGlobal <= __lastGreetingAtGlobal)) {
            try { __lastGreetingBubbleGlobal.remove(); } catch (_) {}
            __lastGreetingBubbleGlobal = null;
            __lastGreetingAtGlobal = 0;
          }

          // 2) Per-project replacement
          const lastUserAt = Number(__lastUserMsgAtByProject[pForMsg] || 0);
          const lastGreetAt = Number(__lastGreetingAtByProject[pForMsg] || 0);
          const lastNode = __lastGreetingBubbleByProject[pForMsg];

          if (lastNode && lastGreetAt && lastUserAt <= lastGreetAt) {
            try { lastNode.remove(); } catch (_) {}
            __lastGreetingBubbleByProject[pForMsg] = null;
            __lastGreetingAtByProject[pForMsg] = 0;
          }
        }
      } catch (_) {}
      // (dedup) removed duplicate greeting replacement block

      const bubble = document.createElement("div");
      bubble.className = "chat-bubble " + (
        role === "user" ? "chat-user" :
        role === "assistant" ? "chat-assistant" :
        "chat-info"
      );

      // Preserve raw, unrendered message for lossless copy (patch blocks, fences, colons, etc.)
      bubble.__rawText = (text == null) ? "" : String(text);

      const ts = document.createElement("span");
      ts.className = "timestamp";

      // (moved) o / isReplay / pForMsg are computed at the top of appendChat()

      ts.textContent = (o.ts && String(o.ts).trim()) ? String(o.ts).trim() : nowTs();
      bubble.appendChild(ts);

      // If this is a greeting, remember it so it can be replaced on repeated switches.
      try {
        const r0 = (role == null) ? "" : String(role);
        const t0 = (text == null) ? "" : String(text);

        if (!isReplay && (r0 === "assistant" || r0 === "info") && isGreetingLikeMessage(t0)) {
          __lastGreetingBubbleByProject[pForMsg] = bubble;
          __lastGreetingAtByProject[pForMsg] = Date.now();

          __lastGreetingBubbleGlobal = bubble;
          __lastGreetingAtGlobal = Date.now();
        }
      } catch (_) {}

      // Record ONLY the last ACTUAL chat message (user/assistant), per project.
      // Never allow Pulse/Resume/status blobs, continuity blurbs, or command-messages to overwrite it.
      // IMPORTANT: Replay must never mutate continuity caches.
      try {
        const r = (role == null) ? "" : String(role);
        const t = (text == null) ? "" : String(text);

        const isRealRole = (r === "user" || r === "assistant");
        const isStatusBlob = looksLikeResumeOrPulseBlob(t);

        if (!isReplay && isRealRole && !isStatusBlob && isActualChatText(t)) {
          // Track last real user message time (stops greeting replacement once user speaks)
          if (r === "user") {
            __lastUserMsgAtByProject[pForMsg] = Date.now();
            __lastUserMsgAtGlobal = Date.now();
          }        
          const entry = { role: r, ts: (ts.textContent || ""), text: t };

          // Track last real chat (either side)
          __lastRealByProject[pForMsg] = entry;
          saveLastRealChat(pForMsg, entry.role, entry.ts, entry.text);

           // (dedup) removed duplicate user-message timestamp write
          // Track last assistant answer (preferred for continuity bubble)
          if (r === "assistant") {
            __lastAssistantByProject[pForMsg] = entry;
            saveLastAssistantChat(pForMsg, entry.role, entry.ts, entry.text);
          }

          // Full thread capture (UI-only)
          threadPush(pForMsg, entry);
        }
      } catch (_) {}

      // If this is a Resume/status blob, treat it as a control message ONLY:
      // - trigger continuity fetch (existing projects)
      // - OR show onboarding only (brand-new projects)
      // - do NOT render as a chat bubble (prevents duplicates).
      try {
        if (role === "assistant" && looksLikeResumeOrPulseBlob(text)) {
          // New project (no goal): don't "resume" into a Pulse ? just show the friendly onboarding.
          if (isBootstrapResumeBlob(text)) {
            // UI deterministic welcome disabled.
            // The backend greeting is requested after thread.history via greeting.request.
            return;
          }

          requestLatestAssistantOutput(activeProjectForStorage());
          return;
        }
      } catch (_) {}

      const msgWrap = document.createElement("div");
      msgWrap.className = "msg";

      // UI-only formatting:
      // - Resume card
      // - simple headers/bullets/paragraphs
      // - /file links stay clickable
      renderStructuredMessage(msgWrap, text);

      bubble.appendChild(msgWrap);

      // Per-message ⧉ icon on user + assistant bubbles (copies that single message).
      if (role === "assistant" || role === "user") {
        const btn = document.createElement("button");
        btn.className = "bubble-copy";
        btn.type = "button";
        btn.textContent = "⧉";
        btn.title = "Copy message";
        btn.setAttribute("aria-label", "Copy message");

        btn.addEventListener("click", async (ev) => {
          ev.preventDefault();
          ev.stopPropagation();

          // Robust decoding: decode valid %XX sequences without choking on stray '%' (e.g., "55%")
          function safePercentDecode(s) {
            if (!s || typeof s !== "string") return "";
            // Treat '+' as space in case the server used x-www-form-urlencoded style.
            const plusFixed = s.replace(/\+/g, " ");
            // Escape any '%' that is NOT followed by two hex digits so decodeURIComponent won't throw.
            const pctFixed = plusFixed.replace(/%(?![0-9A-Fa-f]{2})/g, "%25");
            try {
              return decodeURIComponent(pctFixed);
            } catch (_) {
              // Last resort: return the original text unchanged
              return s;
            }
          }

          async function writeClipboard(textPlain, htmlOptional) {
            // iOS Safari BUG:
            // navigator.clipboard.writeText() re-encodes when pasting into web inputs.
            // Force legacy copy path on iOS (plain text only).
            if (isIOS()) {
              const ta = document.createElement("textarea");
              ta.value = textPlain;
              ta.setAttribute("readonly", "");
              ta.style.position = "fixed";
              ta.style.top = "-1000px";
              ta.style.left = "-1000px";
              document.body.appendChild(ta);
              ta.select();
              try {
                document.execCommand("copy");
                return true;
              } finally {
                document.body.removeChild(ta);
              }
            }

            // Prefer rich copy when available (non-iOS)
            if (
              htmlOptional &&
              navigator.clipboard &&
              navigator.clipboard.write &&
              typeof ClipboardItem !== "undefined"
            ) {
              const item = new ClipboardItem({
                "text/plain": new Blob([textPlain], { type: "text/plain" }),
                "text/html": new Blob([htmlOptional], { type: "text/html" }),
              });
              await navigator.clipboard.write([item]);
              return true;
            }

            // Plain text path
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(textPlain);
              return true;
            }

            // Final fallback
            const ta = document.createElement("textarea");
            ta.value = textPlain;
            ta.setAttribute("readonly", "");
            ta.style.position = "fixed";
            ta.style.top = "-1000px";
            ta.style.left = "-1000px";
            document.body.appendChild(ta);
            ta.select();
            try {
              document.execCommand("copy");
              return true;
            } finally {
              document.body.removeChild(ta);
            }
          }

          try {
            // Copy message content (not timestamp, not ⧉)
            // Provide both plain text + rich HTML when supported.
            // ALWAYS copy raw message text (DOM rendering is lossy for patch blocks)
            let msgPlain = (bubble && bubble.__rawText) ? bubble.__rawText : (text || "");
            msgPlain = normalizeText(msgPlain, 6);

            // Rich HTML (best-effort): wrap to preserve structure when pasting into editors.
            const msgHtml = (msgWrap && msgWrap.innerHTML)
              ? (`<div>${msgWrap.innerHTML}</div>`)
              : "";
              
            await writeClipboard(msgPlain, msgHtml);
            appendInfo("[INFO] Copied.");

          } catch (err) {
            console.error("Per-message copy failed:", err);
            appendInfo("[ERROR] Copy failed.");
          }
        });

        bubble.appendChild(btn);
      }

      logEl.appendChild(bubble);

      // Scroll behavior:
      // - For assistant responses, bring the START of the new response into view.
      // - For user messages and info, keep the traditional "scroll to bottom".
      if (role === "assistant" || role === "info") {
        // Force user to see the beginning of the newest message
        bubble.scrollIntoView({ block: "start", behavior: "smooth" });
      } else {
        // User bubbles can keep classic "bottom" behavior
        logEl.scrollTop = logEl.scrollHeight;
      }
    }
    // --- Unified "thinking" signal (top progress bar only; no chat bubble) ---
    let thinkingActive = false;
    let thinkingCount = 0;

    function showThinking() {
      thinkingCount += 1;
      if (thinkingCount > 1) return;
      thinkingActive = true;
      if (window.BatchProgress && typeof window.BatchProgress.startIndeterminate === "function") {
        window.BatchProgress.startIndeterminate();
      }
    }

    function hideThinking() {
      if (thinkingCount > 0) thinkingCount -= 1;
      if (thinkingCount > 0) return;
      thinkingActive = false;
      if (window.BatchProgress && typeof window.BatchProgress.stopIndeterminate === "function") {
        window.BatchProgress.stopIndeterminate();
      }
    }

    function appendInfo(text) {
      appendChat(text, "info");
    }

    function setStatus(text) {
      statusEl.textContent = text;
    }

    let currentProjectName = "default";

    // Persist the user's chosen project across reconnects (prevents reset to default)
    // NOTE: read legacy key first (lens0-project) for backward compatibility, then migrate to per-user.
    // Persist the user's chosen project across reconnects (prevents reset to default)
// NOTE: read per-user key first (lens0-project:<user>), then fall back to legacy key (lens0-project)
let desiredProjectName = (
  window.localStorage.getItem(projectStorageKey()) ||
  window.localStorage.getItem("lens0-project") ||
  "default"
).trim() || "default";
    // During reconnect, the server may briefly announce "default" before we restore.
    // We ignore that "default" update while this window is active.
    let restoreProjectUntil = 0;

    // --- updateProjectName jitter guard ---
    // updateProjectName is invoked from multiple places; make it idempotent + rate-limited.
let __lastProjectNameSet = "";
let __lastProjectNameSetAt = 0;
const projectTitleMap = Object.create(null);

function prettyChatNameFromProject(name) {
  const n = String(name || "").trim();
  const m = n.match(/^chat_(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})_/);
  if (!m) return "";
  const y = m[1], mo = m[2], da = m[3], hh = m[4], mm = m[5];
  return `Chat ${y}-${mo}-${da} ${hh}:${mm}`;
}

function displayNameForProject(name) {
  const n = String(name || "").trim();
  if (!n) return "";
  const t = String(projectTitleMap[n] || "").trim();
  if (t) return t;
  const pretty = prettyChatNameFromProject(n);
  return pretty || n;
}

function generateNewChatName() {
  const d = new Date();
  const pad = (n) => String(n).padStart(2, "0");
  const y = d.getFullYear();
  const mo = pad(d.getMonth() + 1);
  const da = pad(d.getDate());
  const hh = pad(d.getHours());
  const mm = pad(d.getMinutes());
  const ss = pad(d.getSeconds());
  const rand = Math.random().toString(36).slice(2, 6);
  return `chat_${y}${mo}${da}_${hh}${mm}${ss}_${rand}`;
}

function createNewChat(opts = {}) {
  const name = generateNewChatName();
  if (opts.closeMenu) closeProjectMenu();

  if (ws && ws.readyState === WebSocket.OPEN) {
    noteProjectSwitch("user", name);
    desiredProjectName = name;

    try { ensureThreadVisibleForProject(name); } catch (_) {}

    try {
      const frame = {
        v: 1,
        type: "chat.send",
        text: "!switch project: " + name,
        project: (currentProjectName || desiredProjectName || "default"),
        active_expert: (activeExpert || "default"),
        intent: {}
      };
      attachTrace(frame, "send");
      ws.send(JSON.stringify(frame));
    } catch (_) {}

    showThinking();
  } else {
    appendInfo("[WARN] Not connected - click Connect first.");
  }
}

function updateProjectName(name) {
      if (!name) return;

      const n0 = String(name).trim();
      if (!n0) return;

      // Idempotent: ignore if project is already current
      if (String(currentProjectName || "").trim() === n0) {
        return;
      }

      // Rate-limit: ignore rapid repeats (UI churn protection)
      const now = Date.now();
      if (n0 === __lastProjectNameSet && (now - (__lastProjectNameSetAt || 0)) < 250) {
        return;
      }
      __lastProjectNameSet = n0;
      __lastProjectNameSetAt = now;

      currentProjectName = n0;

      // Project switch must also switch the active expert (per-project expert selection).
      try { syncExpertForProject(name); } catch (_) {}

      // Treat any non-empty project as the user's desired project (persist it)
      // During restore-owned startup, do not let transient "default" overwrite the desired project.
      if (__startupOwner === "restore" && __inStartupWindow() && String(name || "").trim() === "default" && __startupRestoreProject) {
        // keep desiredProjectName as-is
      } else {
        desiredProjectName = name;
      }
      try {
        // Write per-user key (prevents cross-user bleed)
        window.localStorage.setItem(projectStorageKey(), name);

        // Legacy write (optional) so older builds still see something sane
        window.localStorage.setItem("lens0-project", name);
      } catch (_) {}

      // During connect-owned startup, load history ONCE after we learn the real project.
      // This keeps cross-device history consistent without relying on local cache.
      try {
        if (__connectHistoryPending && __startupOwner === "connect" && __inStartupWindow()) {
          __connectHistoryPending = false;
          requestThreadHistoryOnce(n0, "connect");
        }
      } catch (_) {}

      // Human-first greeting is owned by the backend (LLM-based) and appended after thread replay.
      // UI deterministic welcome is disabled for project switches.
      // try { scheduleWelcome("project"); } catch (_) {}

      if (uploadProjectInput) uploadProjectInput.value = name; // optional, may be null
      const display = displayNameForProject(name) || name;
      currentProjectLine.textContent = "Chat: " + display;
       projectNamePill.textContent = "Chat: " + display + " ▾";

       // Server-backed thread replay is explicit-only.
       // Do NOT fetch history on project meta updates (except connect-owned startup above).

       // Local fallback (instant swap if we have cache); server history will overwrite via thread.history frame.
       try { ensureThreadVisibleForProject(name); } catch (_) {}

    }


    function updateProjectMetaFromMessage(msg) {
      try {
        const lines = msg.split(/\r?\n/);
        for (const line of lines) {
          if (line.startsWith("Current project for this connection:")) {
            const name = line.split(":")[1].trim();

            // If reconnecting, don't let the server's initial "default" overwrite the user's desired project
            if (name === "default" && desiredProjectName !== "default" && Date.now() < restoreProjectUntil) {
              // ignore
            } else {
              if (name) updateProjectName(name);
            }

            // Connection is now fully bound to a project → safe to load projects
            if (ws && ws.readyState === WebSocket.OPEN) {
              loadProjects();
            }
          } else if (line.startsWith("Current project:")) {
            // New server dashboard format
            const name = line.split(":")[1].trim();

            if (name === "default" && desiredProjectName !== "default" && Date.now() < restoreProjectUntil) {
              // ignore
            } else {
              if (name) updateProjectName(name);
            }
          } else if (line.startsWith("Project:")) {
            // IMPORTANT: support simplified server greetings (e.g., "Project: myproj")
            const name = line.split(":")[1].trim();

            if (name === "default" && desiredProjectName !== "default" && Date.now() < restoreProjectUntil) {
              // ignore
            } else {
              if (name) updateProjectName(name);
            }
          } else if (line.startsWith("Started new project:")) {
            const name = line.replace("Started new project:", "").split("\n")[0].trim();
            if (name) updateProjectName(name);
          } else if (line.startsWith("Switched current project for this connection to:")) {
            const name = line
              .replace("Switched current project for this connection to:", "")
              .split("\n")[0]
              .trim();
            if (name) updateProjectName(name);
          } else if (line.startsWith("Current project goal:")) {
            const goal = line.split(":")[1].trim();
            currentGoalLine.textContent = "Goal: " + (goal || "(none yet)");
          } else if (line.startsWith("Goal:")) {
            // Dashboard format includes "Goal: ..."
            const goal = line.split(":")[1].trim();
            currentGoalLine.textContent = "Goal: " + (goal || "(none yet)");
          } else if (line.startsWith("Updated goal for project")) {
            const parts = line.split(":", 2);
            if (parts.length === 2) {
              const goal = parts[1].trim();
              currentGoalLine.textContent = "Goal: " + (goal || "(none yet)");
            }
          }
        }
      } catch (e) {
        console.error("Error parsing project meta from message:", e);
      }
    }

    function maybePopulateDashboardFromPlan(msg) {      if (msg.startsWith("Project:") && msg.includes("Goal:") && msg.includes("Checkpoints:")) {
        projectSummaryEl.textContent = msg;
      }
    }

    function maybePopulateFilesFromList(msg) {
      const isList =
        msg.startsWith("Project:") &&
        msg.includes("Documents:") &&
        (msg.includes("Cheat sheets / artifacts:") || msg.includes("Artifacts:"));

      if (isList) {
        projectFilesEl.textContent = msg;
      }
    }

    let reconnectAttempt = 0;
    let reconnectTimer = null;

    function scheduleReconnect() {
      if (manualClose) return;
      if (reconnectTimer) return;

      // Don’t reconnect while login is required.
      if (isLoginVisible()) return;

      // If hidden, arm a reconnect but delay the actual connect() until visible.
      const hiddenNow = !!document.hidden;

      reconnectAttempt = Math.min(reconnectAttempt + 1, 8);
      const delay = Math.min(30000, 500 * (2 ** (reconnectAttempt - 1))); // 0.5s,1s,2s..30s cap

      // If we are hidden, don't show noisy status churn.
      if (!hiddenNow) setStatus(`Reconnecting… (${delay}ms)`);

      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;

        // Wait until visible to actually reconnect (iOS PWA best practice).
        if (document.hidden) {
          scheduleReconnect();
          return;
        }

        connect();
      }, delay);
    }
    function wsUrlWithAuth(baseUrl) {
      const u = (window.__LENS0_AUTH_USER || "").trim();
      const p = (window.__LENS0_AUTH_PASS || "").trim();
      if (!u || !p) return baseUrl;

      // Some server builds expect different query keys. Send a small set of common variants.
      // Server can ignore unknown keys; this maximizes compatibility without needing backend changes.
      const sep = baseUrl.includes("?") ? "&" : "?";
      const eu = encodeURIComponent(u);
      const ep = encodeURIComponent(p);

      return (
        `${baseUrl}${sep}` +
        `user=${eu}&pass=${ep}` +
        `&username=${eu}&password=${ep}` +
        `&u=${eu}&p=${ep}`
      );
    }

    function projectStorageKey() {
      // Per-user storage to prevent Frank/Emanie bleed in the same browser profile
      const u = (window.__LENS0_AUTH_USER || "guest").trim() || "guest";
      return `lens0-project:${u}`;
    }

    async function connect() {
      // Never connect while login overlay is visible (prevents background error loops).
      if (isLoginVisible()) {
        setStatus("Login required");
        return;
      }

      try {
        if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
          return;
        }
        await ensureEndpoints();
        let urlTried = WS_URL;
        console.log("[WS] Connecting to:", urlTried);
        const authedUrl = wsUrlWithAuth(urlTried);
        ws = new WebSocket(authedUrl);
        urlTried = authedUrl;


        ws.__urlTried = urlTried;

      } catch (e) {
        appendInfo("[ERROR] Failed to create WebSocket: " + e);
        return;
      }

      setStatus("Connecting…");

      manualClose = false;

      ws.onopen = () => {
        reconnectAttempt = 0;
        manualClose = false; // authoritative: connection is live
        setStatus("Connected");
        // Keep startup human: no "Connected." chatter.

        // Start a short restore window: ignore the server's initial "default" message
        // while we re-assert the user's last chosen project.
        restoreProjectUntil = Date.now() + 4000;

        const wantsRestore = !!(desiredProjectName && desiredProjectName !== "default");

        // Startup owner: restore decides project + does the only startup history load.
        __startupOwner = wantsRestore ? "restore" : "connect";
        __startupUntil = Date.now() + (wantsRestore ? 9000 : 4500);
        __startupRestoreProject = wantsRestore ? ((desiredProjectName || "").trim() || "default") : "";

        if (wantsRestore) {
          // Auto-restore is NOT a user-initiated switch; do not trigger onboarding popups.
          noteProjectSwitch("restore");

          // Make the UI feel immediate: show whatever we have cached for the desired project first.
          try { ensureThreadVisibleForProject(desiredProjectName); } catch (_) {}

          // Suppress the resume/pulse blob that often replays after restore (mobile pageshow)
          suppressRestoreProject = desiredProjectName;
          suppressRestoreBannersUntil = Date.now() + 8000; // 8s window

          // slight delay: let server send "Project:" meta first so we can avoid redundant switch churn
          setTimeout(() => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;

            const desired = (desiredProjectName || "default").trim() || "default";
            const cur = (currentProjectName || "").trim();
            const alreadyThere = !!cur && (cur === desired);

            if (!alreadyThere) {
              // Use canonical WS frame (no user bubble).
              try {
                const frame = {
                  v: 1,
                  type: "chat.send",
                  text: "!switch project: " + desired,
                  project: desired,
                  active_expert: (activeExpert || "default"),
                  intent: { startup: "restore" }
                };
                attachTrace(frame, "send");
                ws.send(JSON.stringify(frame));
              } catch (_) {}
            }

            // After restore, fetch canonical history ONCE for the desired project.
            setTimeout(() => {
              try { requestThreadHistoryOnce(desired, "restore"); } catch (_) {}
            }, 200);

            // Startup: do NOT request "!last answer" ? thread.get already replays the canonical chat.
            // This avoids flicker/reorder jitter on load.
          }, 250);

        } else {
          // Default connect: do NOT load history or last-answer during startup.
          // Restore owns startup (when applicable). If there is no restore target, we only
          // ensure the UI is pointing at the active project; user can then interact normally.
          const p = activeProjectForStorage();
          try { ensureThreadVisibleForProject(p); } catch (_) {}
          // Wait for the server to announce the real project, then request history once.
          __connectHistoryPending = true;
          // Fallback: if we never hear a project meta line, request history for current storage project.
          setTimeout(() => {
            if (!__connectHistoryPending) return;
            __connectHistoryPending = false;
            try { requestThreadHistoryOnce(activeProjectForStorage(), "connect_fallback"); } catch (_) {}
          }, 1200);
        }
      };


        ws.onclose = (evt) => {
          const triedUrl = (ws && ws.__urlTried) ? ws.__urlTried : (WS_URL || "");
          const code = evt && typeof evt.code === "number" ? evt.code : null;
          const reason = evt && typeof evt.reason === "string" ? evt.reason : "";
          const wasClean = !!(evt && evt.wasClean);

          // Auth-first: if the server closes due to auth/session, stop reconnect loops and require login.
          // NOTE: On iOS screen-lock/background, sockets can die with misleading codes/reasons.
          // We only force-login if we are NOT in/just returned from a background period.
          const rlow = (reason || "").toLowerCase();
           const now = Date.now();
           const recentlyBackgrounded =
             !!(lastHiddenAt && (now - lastHiddenAt) < INACTIVITY_LOGIN_MS) ||
             !!(lastCameBackAt && (now - lastCameBackAt) < RESUME_GRACE_MS);

          const looksLikeAuthClose =
            (code === 1008 || code === 4401 || code === 4403 ||
             rlow.includes("unauth") || rlow.includes("forbidden") || rlow.includes("login"));

          if (looksLikeAuthClose && !document.hidden && !recentlyBackgrounded) {
            manualClose = true;
            stopWsHeartbeat();
            setStatus("Login required");
            showLogin("Session expired - please log in again.");
            ws = null;
            return;
          }

          console.log("[WS] Closed:", { url: triedUrl, code, reason, wasClean });

          // Never show querystring creds in the UI log.
          const safeUrl = (triedUrl || "").split("-")[0];

          // If the page is hidden, close quietly (no spam).
          // BUT: remember it died while hidden so we can reconnect on resume.
          if (document.hidden) {
            wsClosedWhileHidden = true;
            stopWsHeartbeat();
            setStatus("Disconnected");
            ws = null;
            return;
          }

          appendInfo(
            `[INFO] Connection closed: ${safeUrl}` +
            `${code ? " (code " + code + ")" : ""}` +
            `${reason ? " - " + reason : ""}`
          );

          // PWA policy: reconnect automatically unless user explicitly disconnected or login is required.
          setStatus("Disconnected");
          ws = null;

          // If we were backgrounded recently, mark so handleCameBack reconnects immediately.
          try { if (lastHiddenAt) wsClosedWhileHidden = true; } catch (_) {}

          if (!manualClose && !isLoginVisible()) {
            // If visible, reconnect soon.
            if (!document.hidden) {
              scheduleReconnect();
            }
          }
        };

        ws.onerror = (e) => {
          const triedUrl = (ws && ws.__urlTried) ? ws.__urlTried : (WS_URL || "");
          console.error("[WS] error on", triedUrl, e);

          // Don’t spam the chat while hidden or while login-gated.
          if (document.hidden) return;
          if (isLoginVisible()) return;

          // If we have a fallback and haven't tried it yet, avoid a scary error line.
          // onclose will handle switching to fallback.
          try {
            const fb = (window.__lens0WsFallback || "").trim();
            if (!wsFallbackTried && fb && fb !== triedUrl) return;
          } catch (_) {}

          appendInfo("[ERROR] WebSocket error (see console)");
        };

      ws.onmessage = (event) => {
        const raw = event.data;

        // Heartbeat pong
        if (raw === "__pong__") {
          wsLastPongAt = Date.now();
          return;
        }

        if (typeof raw !== "string") {
          appendInfo("[WARN] Non-text message from server");
          return;
        }

        // Decode server text if it arrives percent-encoded (but don't break literal '%' like "55%").
        function safePercentDecode(s) {
          if (!s || typeof s !== "string") return "";
          // Treat '+' as space in case of x-www-form-urlencoded style.
          const plusFixed = s.replace(/\+/g, " ");
          // Escape any '%' that is NOT followed by two hex digits so decodeURIComponent won't throw.
          const pctFixed = plusFixed.replace(/%(?![0-9A-Fa-f]{2})/g, "%25");
          try {
            return decodeURIComponent(pctFixed);
          } catch (_) {
            return s; // last resort: show raw
          }
        }

        // Handle WS frame envelope (v1) + legacy JSON wrappers.
        let payload = raw;

        if (payload && payload[0] === "{") {
          try {
            const obj = JSON.parse(payload);
            if (obj && typeof obj === "object") {
              // Preferred framed messages
              if (obj.v === 1 && typeof obj.type === "string") {
                const t = obj.type;
                try {
                  const tid = String(obj.trace_id || "").trim();
                  if (tid) {
                    lastTraceId = tid;
                    recordTraceEvent({ dir: "recv", type: t, trace_id: tid, ts: new Date().toISOString() });
                    console.log("[TRACE] recv", t, tid);
                  }
                } catch (_) {}
                 // Heartbeat pong (framed)
                 if (t === "ws.pong") {
                   wsLastPongAt = Date.now();
                   return;
                 }
                // Upload pipeline frames (no chat parsing)
                if (t === "upload.status") {
                  if (
                    window.UploadCenter &&
                    typeof window.UploadCenter.consumeStatusFrame === "function"
                  ) {
                    window.UploadCenter.consumeStatusFrame(obj);
                    return; // critical: stop chat append
                  }
                }
                if (t === "upload.batch.progress") {
                  if (
                    window.BatchProgress &&
                    typeof window.BatchProgress.consumeFrame === "function"
                  ) {
                    window.BatchProgress.consumeFrame(obj);
                    return; // critical: stop chat append
                  }
                }
                // Debug usage frames (hidden panel)
                if (t === "debug.usage") {
                  lastUsageFrame = obj;
                  if (debugVisible) renderUsageDebug();
                  return; // critical: stop chat append
                }
                if (t === "trace.dump") {
                  try {
                    serverTraceDump = Array.isArray(obj.events) ? obj.events : [];
                    if (traceVisible) renderTraceDebug();
                  } catch (_) {}
                  return; // critical: stop chat append
                }

                // Thread history (server-backed, token-free)
                // Server sends: { v:1, type:"thread.history", project:"...", messages:[{role,ts,text},...] }
                 if (t === "thread.history") {
                   try {
                     const proj = String(obj.project || "").trim() || (currentProjectName || desiredProjectName || "default");
                     const msgs = Array.isArray(obj.messages) ? obj.messages : [];

                     // If we have history, clear + replay.
                     if (msgs.length > 0) {
                       try { if (logEl) logEl.innerHTML = ""; } catch (_) {}
                       for (const m of msgs) {
                         if (!m || typeof m !== "object") continue;
                         const role0 = String(m.role || "").trim().toLowerCase();
                         const ts0 = String(m.ts || "").trim();
                         const text0 = (m.text == null) ? "" : String(m.text);
                         if (!text0.trim()) continue;
                         if ((role0 === "assistant" || role0 === "info") && isGreetingLikeMessage(text0)) continue;
                         const uiRole = (role0 === "user" || role0 === "assistant") ? role0 : "info";
                         appendChat(text0, uiRole, { isReplay: true, ts: ts0, project: proj });
                       }
                     }

                    // Ask the server for a contextual greeting AFTER history replay.
                    // Runs on both new projects and switches; the server can decide to no-op.
                    try {
                      if (ws && ws.readyState === WebSocket.OPEN) {
                        const p = String(proj || "").trim() || "default";
                        const now = Date.now();
                        const last = __greetReqLastAt[p] || 0;

                        // Only request greeting once per project per short window
                        if ((now - last) >= 6000) {
                          __greetReqLastAt[p] = now;
                          const reason = (msgs.length === 0) ? "new_project" : "switch_project";
                          const frame = { v: 1, type: "greeting.request", project: p, reason };
                          attachTrace(frame, "send");
                          ws.send(JSON.stringify(frame));
                        }
                      }
                    } catch (_) {}
                   } catch (_) {}
                   return; // critical: stop default chat append
                 }

                // Default framed payload (server may still send chat as plain string elsewhere)
                if (typeof obj.text === "string") payload = obj.text;
                else if (typeof obj.message === "string") payload = obj.message;
                else if (typeof obj.data === "string") payload = obj.data;
                else payload = raw;
              } else {
                // Legacy JSON wrapper
                if (typeof obj.text === "string") payload = obj.text;
                else if (typeof obj.message === "string") payload = obj.message;
                else if (typeof obj.data === "string") payload = obj.data;

                // Deliverable/link frames: normalize into a user-visible "Open: ..." line
                else if (typeof obj.open === "string") payload = "Open: " + obj.open;
                else if (typeof obj.href === "string") payload = "Open: " + obj.href;
                else if (typeof obj.path === "string") {
                  const p = String(obj.path || "").trim();
                  payload = "Open: " + (p.startsWith("/file-path=") ? p : (p.startsWith("projects/") ? ("/file-path=" + p) : p));
                } else if (typeof obj.relative_path === "string") {
                  const p = String(obj.relative_path || "").trim();
                  payload = "Open: " + (p.startsWith("/file-path=") ? p : (p.startsWith("projects/") ? ("/file-path=" + p) : p));
                }
              }
            }
          } catch (_) {
            // not JSON; ignore
          }
        }

        // Iterative decode (bounded): fixes double-encoded strings where '%25' survives one pass.
        function decodeMany(s, maxPasses = 6) {
          let cur = s;
          for (let i = 0; i < maxPasses; i++) {
            if (!(cur.includes("%") || /%[0-9A-Fa-f]{2}/.test(cur))) break;
            const next = safePercentDecode(cur);
            if (next === cur) break;
            cur = next;
          }
          return cur;
        }

        let msg = normalizeText(payload, 6);

        // UI-only: remove internal/system narration and normalize tone
        const __lens0_beforeSanitize = msg;
        msg = sanitizeAssistantMessage(msg);

        // If sanitization stripped everything, show a visible warning instead of "no response".
        if (!msg || !String(msg).trim()) {
          console.warn("[UI] sanitizeAssistantMessage() stripped the whole message.", { before: __lens0_beforeSanitize });
          msg = "[WARN] Assistant message was emptied by UI sanitization (UI bug). Check sanitizeAssistantMessage() rules.";
        }


        // Mobile: strip backend implementation noise (server color, endpoints, etc.)
        // Keep the user-facing meaning; drop the plumbing.
        if (isMobile() && msg) {
          const filtered = msg
            .split(/\r?\n/)
            .filter((ln) => {
              const s = (ln || "").trim();
              if (!s) return true;

              // Drop these lines on mobile
              if (s.startsWith("Server: [") || s.includes("[GREEN ACTIVE]") || s.includes("[BLUE ACTIVE]")) return false;
              if (s.startsWith("Server:") && s.toLowerCase().includes("connected")) return false;
              if (s.startsWith("Self-patch") || s.startsWith("Self patch")) return false;
              if (s.startsWith("Server:") && s.includes("ws://")) return false;
              if (s.startsWith("Server:") && s.includes("http://")) return false;

              return true;
            })
            .join("\n");

          // Reassign display text (keep variable name used below)
          // NOTE: we keep the original `msg` identifier by shadowing into a new constant.
          // This is safe because the rest of the handler only reads `msg`.
          // eslint-disable-next-line no-inner-declarations
          function __lens0_setMsg(v) { return v; }
          // @ts-ignore
          msg = __lens0_setMsg(filtered);
        }

        // If the server rejected auth, stop reconnect loop and force login
        if (msg.includes("Unauthorized") || msg.includes("unauthorized")) {
          manualClose = true;
          setStatus("Login required");
          showLogin("Please log in.");
          return;
        }

        updateProjectMetaFromMessage(msg);

        // Suppress/strip server greeting/meta blobs from appearing as chat.
        // IMPORTANT: if a message contains BOTH meta lines and a human greeting,
        // strip the meta lines and keep the human content (never blank).
        try {
          const t0 = String(msg || "");
          const t = t0.trim();

          // Pure project-only (single-line) meta should be hidden after we parse it.
          const projectOnly =
            t.startsWith("Project:") &&
            !t.includes("\n") &&
            !t.includes("Goal:") &&
            !t.includes("Current project goal:") &&
            !t.includes("Resume:") &&
            !t.includes("Project Pulse");

          if (projectOnly) return;

          // If the message begins with meta header lines, strip them and keep the rest.
          // This allows the server to send:
          //   Project: X
          //   Current project goal: Y
          //   <human greeting...>
          // without the UI dropping the greeting.
          if (t.startsWith("Project:") && t.includes("\n")) {
            const lines = t0.split(/\r?\n/);
            const kept = [];
            for (const ln of lines) {
              const s = String(ln || "").trim();
              if (!s) continue;
              if (/^Project:\s+/i.test(s)) continue;
              if (/^Current project goal:\s+/i.test(s)) continue;
              if (/^Goal:\s+/i.test(s)) continue;
              kept.push(ln);
            }
            const rem = kept.join("\n").trim();
            if (!rem) return;     // it really was only meta
            msg = rem;            // keep the human part
          }

          // Extra safety: hide any legacy server dumps if they reappear
          if (t.includes("Last assistant output (most recent):")) return;
          if (t.includes("[GREEN ACTIVE] Connected.")) return;
          if (t.includes("[BLUE ACTIVE] Connected.")) return;
          if (t.includes("No assistant_output artifacts yet.")) return;
        } catch (_) {}

        // --- Minimal continuity: fetch latest assistant_output via server "last answer" ---
        if (__lastAnswerFetchPending) {
          const age = Date.now() - (__lastAnswerFetchAt || 0);

          // If the server returns an inline bootstrap pulse (new project), suppress it.
          // We want the friendly onboarding message to be the first thing the user sees.
          if (age <= 3500 && looksLikeBootstrapPulse(msg)) {
            __lastAnswerFetchPending = false;
            try { scheduleWelcome("project"); } catch (_) {}
            return;
          }

          // We expect exactly: "/file-path=projects/.../artifacts/assistant_output_...md"
          if (age <= 3500 && msg.startsWith("/file-path=")) {
            __lastAnswerFetchPending = false;

            // Fetch the file content and append as assistant
            fetchAndAppendAssistantOutputHref(msg);

            // Do NOT display the /file-path line in chat
            return;
          }

          if (age > 3500) {
            __lastAnswerFetchPending = false;
          }
        }


        // Restore reconnect (mobile): suppress repeated Resume/Project Pulse status blob
        // so it doesn't "pop up" every time Safari returns to the tab.
        if (
          lastProjectSwitchReason === "restore" &&
          Date.now() < suppressRestoreBannersUntil &&
          looksLikeResumeOrPulseBlob(msg)
        ) {
          // Once we suppress one, stop suppressing further content.
          suppressRestoreBannersUntil = 0;
          return;
        }

        // UI-only onboarding DISABLED.
        // Reason: it hijacks turn 1 and prevents Expert Frame Lock / backend guidance from showing.
        // Bootstrap guidance must come from the backend pipeline, not the UI shell.
        if (false && shouldShowGoalOnboard(msg)) {
          const onboardProject = parseProjectNameFromMsg(msg) || currentProjectName || "default";

          appendChat(
            "New chat - let's get you set up.\n\nWhat are we trying to accomplish here-",
            "assistant"
          );

          markGoalOnboardShown(onboardProject);

          // Suppress the redundant server “fresh project” status blob under the onboarding prompt.
          return;
        }
        maybePopulateDashboardFromPlan(msg);
        maybePopulateFilesFromList(msg);
        // Mobile: during reconnect/project-restore, hide the initial "Project: default" greeting.
        // The UI immediately switches to the last project; showing "default" first is confusing.
        if (isMobile() && desiredProjectName && desiredProjectName !== "default" && Date.now() < restoreProjectUntil) {
          const looksLikeDefaultGreeting =
            msg.includes("Project: default") ||
            msg.includes("Current project: default") ||
            msg.includes("Current project for this connection: default");

          const looksLikeExplicitSwitch =
            msg.startsWith("Started new project:") ||
            msg.startsWith("Switched current project for this connection to:") ||
            msg.includes("Switched current project for this connection to:");

          if (looksLikeDefaultGreeting && !looksLikeExplicitSwitch) {
            return; // suppress this one noisy message
          }
        }

        // Show full content on mobile (no collapsing).
        // We still rely on earlier filtering to remove plumbing noise.
        const shown = msg;

        // Never show "Server:" ? keep the conversation human on all devices.
        hideThinking();
        appendChat(shown, "assistant");


        // Continuity: show last assistant answer ONCE after login / explicit project switch
        if (looksLikeResumeOrPulseBlob(shown)) {
          const pulseProject = parseProjectNameFromMsg(shown) || currentProjectName || desiredProjectName || "default";

          const armed =
            __continuityArmedUntil &&
            Date.now() < __continuityArmedUntil &&
            (__continuityArmedReason === "login" || __continuityArmedReason === "user" || __continuityArmedReason === "restore") &&
            (__continuityArmedProject || "default") === (pulseProject || "default");

          if (armed) {
            requestLatestAssistantOutput(pulseProject);
            disarmContinuity();
          }
        }


        // Continuity bubble disabled (it was polluting chat with repeated "Last answer" blocks)
        // If we want continuity later, we will re-add it cleanly and only on login/switch events.
      };
    }

    function disconnect() {
      manualClose = true;
      stopWsHeartbeat();

      // Manual disconnect should not keep stale credentials around.
      clearTransientAuth();

      if (ws) {
        ws.close();
        ws = null;
      }
      setStatus("Disconnected");
    }
    function buildDeliverableHint() {
      return (
        `\n\n[DELIVERABLE]\n` +
        `When the user asks for an itinerary, document, plan, checklist, or any “results”, you MUST produce a print-ready HTML deliverable.\n` +
        `Put the full HTML into a block tagged exactly: [DELIVERABLE_HTML] ... [/DELIVERABLE_HTML].\n` +
        `Never paste the HTML into the chat text. USER_ANSWER must stay short and readable.\n` +
        `Do NOT invent file paths. The server will save the deliverable and the UI will get a real /file link.\n` +
        `In [USER_ANSWER], give a short summary and end with: "Open: /file-path=..." only if provided by the server.\n` +
        `If images are requested, include them in the HTML and also output their /file-path links.\n` +
        `[/DELIVERABLE]\n`
      );
    }

    function looksLikeDeliverableRequest(userText) {
      const t = (userText || "").toLowerCase();
      return (
        t.includes("itinerary") ||
        t.includes("make a document") ||
        t.includes("write a document") ||
        t.includes("create a document") ||
        t.includes("print") ||
        t.includes("print ready") ||
        t.includes("generate") ||
        t.includes("make me") ||
        t.includes("build me") ||
        t.includes("plan") ||
        t.includes("checklist") ||
        t.includes("proposal") ||
        t.includes("draft")
      );
    }

    function buildProjectScopeHint() {
      const p = (currentProjectName || "").trim() || "default";
      // Keep it short to avoid token waste. This is “behind the scenes”.
      return `\n\n[SCOPE]\nUse ONLY files and context from the current project: "${p}". Do not mention or pull from other projects unless the user explicitly asks to switch projects.\n[/SCOPE]\n`;
    }

    function shouldScopeWrap(userText) {
      const t = (userText || "").trim().toLowerCase();

      // Don’t wrap explicit project switching or one-word command macros
      if (t.startsWith("switch project:")) return false;
      if (t === "list" || t === "plan" || t === "refresh state") return false;
      if (t.startsWith("mode:")) return false;

      return true;
    }
    // --- Goal onboarding (UI-only; makes new projects feel guided) ---
    function goalOnboardKey(projectName) {
      const u = (window.__LENS0_AUTH_USER || "guest").trim() || "guest";
      const p = (projectName || "default").trim() || "default";
      return `lens0-goal-onboard-shown:${u}:${p}`;
    }

    function isGoalUnset() {
      const goalText = (currentGoalLine && currentGoalLine.textContent) ? currentGoalLine.textContent : "";
      return goalText.includes("(none yet)") || goalText.toLowerCase().includes("not set yet");
    }

    function shouldShowGoalOnboard(msg) {
      // Only show if:
      // - goal is unset
      // - server indicates fresh project
      // - we have a recent allowed switch intent (login/user switch)
      // - we haven't shown onboarding for THIS project yet
      if (!isGoalUnset()) return false;

      const m = (msg || "").toLowerCase();
      const fresh =
        m.includes("chat tail empty") ||
        m.includes("(not yet recorded)") ||
        m.includes("goal: not set yet");

      if (!fresh) return false;

      // Determine which project this message is talking about.
      const msgProject = parseProjectNameFromMsg(msg) || currentProjectName || "default";

      // Block onboarding during auto-restore reconnects
      if (lastProjectSwitchReason === "restore") return false;

      // Only allow onboarding right after login or an explicit user switch
      const allowedReason = (lastProjectSwitchReason === "login" || lastProjectSwitchReason === "user");
      const recent = (Date.now() - lastProjectSwitchAt) <= 6000; // 6s window
      if (!(allowedReason && recent)) return false;

      try {
        const k = goalOnboardKey(msgProject);
        return window.localStorage.getItem(k) !== "1";
      } catch (_) {
        return true;
      }
    }

    function markGoalOnboardShown(projectName) {
      try {
        const p = (projectName || currentProjectName || "default").trim() || "default";
        const k = goalOnboardKey(p);
        window.localStorage.setItem(k, "1");
      } catch (_) {}
    }

    function buildGoalOnboardingHint() {
      const p = (currentProjectName || "").trim() || "default";

      // Hidden instruction to the model, but user-visible convo stays normal.
      // Goal: short clarification loop, then model outputs a final "Goal: ..." line for the user to confirm.
      return (
        `\n\n[GOAL_ONBOARD]\n` +
        `We are starting a NEW project named "${p}". The goal is not set.\n` +
        `Act like a professional guiding the user. Ask at most 2 short clarifying questions.\n` +
        `Then propose a single crisp goal sentence and ASK: "Confirm- (yes/no)".\n` +
        `If user confirms, output a line exactly like: Goal: <final goal> (and nothing else on that line).\n` +
        `Do NOT mention other projects unless the user explicitly asks.\n` +
        `[/GOAL_ONBOARD]\n`
      );
    }

    function send(text) {
      if (!text || !String(text).trim()) return;

      if (!ws) {
        appendInfo("[WARN] Not connected – no WebSocket.");
        return;
      }
      if (ws.readyState !== WebSocket.OPEN) {
        appendInfo(`[WARN] Not connected – socket state=${ws.readyState}`);
        return;
      }

      appendChat(text, "user");
      // If the user manually issues a project switch, arm continuity for that target.
      try {
        const t = String(text || "").trim();
        const low = t.toLowerCase();
        if (low.startsWith("switch project:") || low.startsWith("use project:") || low.startsWith("new project:") || low.startsWith("start project:")) {
          const parts = t.split(":", 2);
          const target = (parts.length === 2 ? parts[1] : "").trim();
          if (target) noteProjectSwitch("user", target);
        }
      } catch (_) {}

      let outbound = text;

      if (ENABLE_UI_PROMPT_INJECTION && shouldScopeWrap(text)) {
        outbound = outbound + buildProjectScopeHint();
      }

      // Goal onboarding prompt injection DISABLED.
      // Reason: bootstrap + framing must be owned by backend (EFL), not UI.
      if (false && isGoalUnset() && shouldScopeWrap(text)) {
        outbound = outbound + buildGoalOnboardingHint();
      }

      // If user is requesting a deliverable, force a print-ready file + link
      // NOTE: backend-authoritative mode keeps this OFF unless explicitly enabled.
      if (ENABLE_UI_PROMPT_INJECTION && shouldScopeWrap(text) && looksLikeDeliverableRequest(text)) {
        outbound = outbound + buildDeliverableHint();
      }

      try {
        // Preferred WS frame envelope (v1)
        const frame = {
          v: 1,
          type: "chat.send",
          text: outbound,
          project: (currentProjectName || "default"),
          active_expert: (activeExpert || "default"),
          intent: {}
        };
        attachTrace(frame, "send");
        ws.send(JSON.stringify(frame));
        showThinking();
      } catch (e) {
        // Legacy fallback
        try {
          ws.send(outbound);
          showThinking();
        } catch (e2) {
          console.error("[UI] ws.send failed:", e2);
          appendInfo("[ERROR] Failed to send message to server. See console.");
        }
      }
    }


    // Prompt send / keyboard
    sendBtn.addEventListener("click", () => {
      const text = (promptEl.value || "").trim();
      if (!text) return;

      send(text);

      // Clear + reset, then dismiss keyboard
      promptEl.value = "";
      autoGrow(promptEl);
      updateComposerChipState();

      // Dismiss keyboard + allow compact mode to apply
      try { promptEl.blur(); } catch (_) {}
      updateComposerChipState();
    });

    // Desktop: Enter sends, Shift+Enter inserts newline.
    // Mobile: keep existing behavior (Enter/newline; send via button).
    promptEl.addEventListener("keydown", (e) => {
      try {
        if (isMobile()) return;
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendFromPrompt();
        }
      } catch (_) {}
    });

    function focusPromptNoScroll() {
      if (!promptEl) return;
      try {
        promptEl.focus({ preventScroll: true });
      } catch (_) {
        promptEl.focus();
      }
    }

    function sendFromPrompt() {
      const text = (promptEl.value || "").trim();
      if (!text) return;
      send(text);
      promptEl.value = "";
      autoGrow(promptEl);
      updateComposerChipState();
      // do not re-focus (we want keyboard to dismiss)
    }

    function searchFromPrompt() {
      const base = (promptEl.value || "").trim();
      if (!base) {
        // Keep keyboard up so user can type the search query
        promptEl.value = "[SEARCH] ";
        autoGrow(promptEl);
        updateComposerChipState();
        focusPromptNoScroll();
        return;
      }
      send("[SEARCH] " + base);
      promptEl.value = "";
      autoGrow(promptEl);
      updateComposerChipState();
      // do not re-focus (we want keyboard to dismiss)
    }

    // Mobile chips: allow blur (keyboard dismiss) after send/search.
    if (sendChip) {
      sendChip.addEventListener("click", () => {
        sendFromPrompt();
        try { promptEl.blur(); } catch (_) {}
        updateComposerChipState();
      });
    }

    // Normalize pasted text: if clipboard contains percent-encoded sequences (often double-encoded),
    // decode them before they land in the textarea.
    promptEl.addEventListener("paste", (e) => {
      try {
        const cd = e.clipboardData || window.clipboardData;
        const pasted = cd && cd.getData ? cd.getData("text") : "";
        if (!pasted) return; // let default happen

        function safePercentDecode(s) {
          if (!s || typeof s !== "string") return "";
          const plusFixed = s.replace(/\+/g, " ");
          const pctFixed = plusFixed.replace(/%(?![0-9A-Fa-f]{2})/g, "%25");
          try {
            return decodeURIComponent(pctFixed);
          } catch (_) {
            return s;
          }
        }

        function decodeMany(s, maxPasses = 4) {
          let cur = s;
          for (let i = 0; i < maxPasses; i++) {
            if (!(cur.includes("%") || /%[0-9A-Fa-f]{2}/.test(cur))) break;
            const next = safePercentDecode(cur);
            if (next === cur) break;
            cur = next;
          }
          return cur;
        }

        const normalized = decodeMany(pasted, 4);

        // If nothing changes, don't interfere.
        if (normalized === pasted) return;

        // Replace the default paste with our normalized paste.
        e.preventDefault();

        const start = promptEl.selectionStart ?? promptEl.value.length;
        const end = promptEl.selectionEnd ?? promptEl.value.length;

        const before = promptEl.value.slice(0, start);
        const after = promptEl.value.slice(end);
        promptEl.value = before + normalized + after;

        const caret = start + normalized.length;
        promptEl.selectionStart = caret;
        promptEl.selectionEnd = caret;

        autoGrow(promptEl);
      } catch (_) {
        // If anything goes wrong, fall back to normal paste behavior.
      }
    });

    function keepPromptCaretVisible() {
      if (!promptEl) return;

      // Only needed when content exceeds the visible area (i.e., textarea scrolls internally)
      // Run on next frame so scrollHeight is accurate after layout.
      requestAnimationFrame(() => {
        try {
          promptEl.scrollTop = promptEl.scrollHeight;
        } catch (_) {}
      });
    }

    // Auto-grow the prompt like ChatGPT (up to a cap)
    function autoGrow(el) {
      const max = 160; // px
      el.style.height = "auto";
      el.style.height = Math.min(el.scrollHeight, max) + "px";
    }
    promptEl.addEventListener("input", () => {
      autoGrow(promptEl);
      updateComposerChipState();
      keepPromptCaretVisible();
    });
    window.addEventListener("load", () => {
      autoGrow(promptEl);
      updateComposerChipState();
      keepPromptCaretVisible();
    });

    // Copy chat removed (use per-message ⧉ only).

    // Control buttons
    connectBtn.addEventListener("click", connect);
    disconnectBtn.addEventListener("click", disconnect);

    document.querySelectorAll("button[data-mode]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const mode = btn.getAttribute("data-mode");
        send("mode: " + mode);
      });
    });

    // Command runner
    runCommandBtn.addEventListener("click", () => {
      const cmd = (commandInput.value || "").trim();
      if (!cmd) return;
      send(cmd);
      commandInput.value = "";
    });

    commandInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        runCommandBtn.click();
      }
    });

    // Chat list helpers
    async function loadProjects() {
      try {
        const res = await fetch(`${API_ORIGIN}/list_projects`);
        if (!res.ok) {
          appendInfo(`[ERROR] Failed to list chats: HTTP ${res.status}`);
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          appendInfo(`[ERROR] Failed to list chats: ${data.error || "unknown error"}`);
          return;
        }

        const items = data.projects || [];
        projectListEl.innerHTML = "";

        if (!items.length) {
          projectListEl.textContent = "(no chats yet)";
          return;
        }

        items.forEach((item, idx) => {
          let name = "";
          let title = "";
          if (typeof item === "string") {
            name = item;
          } else if (item && typeof item === "object") {
            name = String(item.name || "").trim();
            title = String(item.title || "").trim();
          }
          if (!name) return;
          if (title) projectTitleMap[name] = title;

          const btn = document.createElement("button");
          btn.textContent = `${idx + 1}) ${displayNameForProject(name)}`;
          btn.style.display = "block";
          btn.style.width = "100%";
          btn.style.marginBottom = "2px";
          btn.style.fontSize = "12px";

          btn.addEventListener("click", () => {
            if (!ws) {
              appendInfo("[WARN] Not connected; no WebSocket.");
              return;
            }
            if (ws.readyState !== WebSocket.OPEN) {
              appendInfo("[WARN] Not connected; socket not open.");
              return;
            }

            closeProjectMenu();

            // Arm continuity for the explicit target project
            noteProjectSwitch("user", name);
            desiredProjectName = name;

            // Switch by name (not by index)
            // Use canonical WS frame (no user bubble).
            try {
              const frame = {
                v: 1,
                type: "chat.send",
                text: "!switch project: " + name,
                project: (currentProjectName || desiredProjectName || "default"),
                active_expert: (activeExpert || "default"),
                intent: {}
              };
              attachTrace(frame, "send");
              ws.send(JSON.stringify(frame));
            } catch (_) {}

            showThinking();
          });

          projectListEl.appendChild(btn);
        });
      } catch (err) {
        appendInfo(`[ERROR] Failed to list chats: ${err && err.message ? err.message : err}`);
      }
    }

    refreshProjectsBtn.addEventListener("click", loadProjects);

    if (newChatBtn) newChatBtn.addEventListener("click", () => {
      createNewChat({ closeMenu: false });
    });

    // Plan/files helpers
    // Server supports "refresh state" (model rebuild) and dashboard message
    refreshPlanBtn.addEventListener("click", () => send("refresh state"));
    refreshFilesBtn.addEventListener("click", () => send("list"));

    // Drag & drop upload – both dedicated box and whole chat area
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Dedicated drop zone is optional (we removed it on mobile to save space)
    if (dropZone) {
      ["dragenter", "dragover"].forEach((eventName) => {
        dropZone.addEventListener(eventName, (e) => {
          preventDefaults(e);
          dropZone.classList.add("dragover");
        });
      });

      ["dragleave", "drop"].forEach((eventName) => {
        dropZone.addEventListener(eventName, (e) => {
          preventDefaults(e);
          dropZone.classList.remove("dragover");
        });
      });

      dropZone.addEventListener("click", () => fileInput.click());
    }

    ["dragenter", "dragover"].forEach((eventName) => {
      logContainer.addEventListener(eventName, (e) => {
        preventDefaults(e);
        chatDropOverlay.classList.add("visible");
      });
    });

    ["dragleave", "drop"].forEach((eventName) => {
      logContainer.addEventListener(eventName, (e) => {
        preventDefaults(e);
        chatDropOverlay.classList.remove("visible");
      });
    });

    logContainer.addEventListener("drop", (e) => {
      const files = e.dataTransfer?.files;
      if (files && files.length) {
        handleFiles(files);
      }
    });

    fileInput.addEventListener("change", (e) => {
      const files = e.target.files;
      if (files && files.length) handleFiles(files);
    });

    // --- Upload Center (keeps chat clean; results live in the top bar bubble) ---
    const UploadCenter = (() => {
      const indicator = document.getElementById("uploadIndicator");
      const badge = document.getElementById("uploadBadge");
      const menu = document.getElementById("uploadMenu");

      // key: savedName (basename) -> item
      const items = new Map();

      // map original filename (lowercased) -> saved key
      const originalIndex = new Map();

      let activeCount = 0;
      let unreadDone = 0;

      function basename(p) {
        const s = String(p || "");
        const idx = s.lastIndexOf("/");
        return idx >= 0 ? s.slice(idx + 1) : s;
      }
            function canonName(x) {
        // Normalize file names across: spaces vs underscores, case, odd separators
        return String(x || "")
          .trim()
          .toLowerCase()
          .replace(/\s+/g, "_")
          .replace(/_+/g, "_");
      }

      function resolveKeyFromName(nameMaybeOriginalOrSaved) {
        const raw = (nameMaybeOriginalOrSaved || "").trim();
        if (!raw) return "";

        // If it already looks like a path, reduce to basename
        const b = basename(raw).trim();
        if (!b) return "";

        // 1) Direct key match
        if (items.has(b)) return b;

        // 2) Original filename match (WS uses original names)
        const k = originalIndex.get(canonName(b));
        if (k && items.has(k)) return k;

        // 3) Fallback: scan items for originalName match (covers cases where originalIndex missed)
        const cb = canonName(b);
        for (const it of items.values()) {
          const on = canonName(it.originalName || "");
          if (on && on === cb) return it.key;
        }

        return b; // last resort: create new
      }

      function isAnalysisHat() {
        return String(activeExpert || "").trim().toLowerCase() === "analysis";
      }

      function requestSynthesis(it, opts = {}) {
        try {
          if (!it) return;
          if (!ws || ws.readyState !== WebSocket.OPEN) return;
          const proj = String(currentProjectName || "default").trim() || "default";
          const payload = {
            v: 1,
            type: "upload.synthesize",
            project: proj,
            file_key: String(it.key || "").trim(),
            relative_path: String(it.relPath || "").trim(),
            orig_name: String(it.originalName || it.key || "").trim(),
            force: !!opts.force
          };
          attachTrace(payload, "send");
          ws.send(JSON.stringify(payload));
          showThinking();
        } catch (_) {}
      }

      function setIndicatorActive(on) {
        if (!indicator) return;
        indicator.classList.toggle("active", !!on);
      }

      function setBadge(n) {
        if (!badge) return;
        const val = Number(n || 0);
        if (val > 0) {
          badge.style.display = "";
          badge.textContent = String(val);
        } else {
          badge.style.display = "none";
          badge.textContent = "0";
        }
      }

      function ensureItem(savedName, originalName) {
        const key = String(savedName || "").trim();
        if (!key) return null;

        if (!items.has(key)) {
          items.set(key, {
            key,
            originalName: originalName || "",
            status: "queued",
            detail: "",
            relPath: "",
            open: false
          });
        } else {
          // If we already had the item but originalName is now known, keep it.
          const it = items.get(key);
          if (it && !it.originalName && originalName) it.originalName = originalName || "";
        }

        const it = items.get(key);

        // Keep a reverse index so WS updates (which use original filenames) can resolve to the same item
        const on = (originalName || (it ? it.originalName : "") || "").trim();
        if (on) originalIndex.set(canonName(on), key);

        return it;
      }

      function render() {
        if (!menu) return;

        // --- Merge duplicates: one row should contain BOTH relPath (image) + detail (answer) ---
        // Some messages key by saved basename; others key by original filename.
        // If they represent the same upload, merge them here.
        try {
          const byOrig = new Map(); // canon(originalName) -> primaryKey

          for (const it of Array.from(items.values())) {
            const on = canonName(it.originalName || "");
            if (!on) continue;

            if (!byOrig.has(on)) {
              byOrig.set(on, it.key);
              continue;
            }

            const primaryKey = byOrig.get(on);
            const primary = items.get(primaryKey);
            if (!primary || primary === it) continue;

            // Choose which is primary: prefer one with relPath; if both, prefer one with longer detail
            let keep = primary;
            let drop = it;

            const keepHasImg = !!(keep.relPath || "").trim();
            const dropHasImg = !!(drop.relPath || "").trim();

            if (!keepHasImg && dropHasImg) {
              keep = drop;
              drop = primary;
            } else if (keepHasImg === dropHasImg) {
              const keepLen = ((keep.detail || "").trim()).length;
              const dropLen = ((drop.detail || "").trim()).length;
              if (dropLen > keepLen) {
                keep = drop;
                drop = primary;
              }
            }

            // Merge fields
            if (!(keep.relPath || "").trim() && (drop.relPath || "").trim()) keep.relPath = drop.relPath;
            if (!(keep.detail || "").trim() && (drop.detail || "").trim()) keep.detail = drop.detail;

            // Prefer "done" if either is done; otherwise keep the more advanced status
            const rank = (s) => {
              const v = String(s || "").toLowerCase();
              if (v === "done") return 4;
              if (v === "processing") return 3;
              if (v === "uploading") return 2;
              if (v === "queued") return 1;
              if (v === "error") return 0;
              return 1;
            };
            if (rank(drop.status) > rank(keep.status)) keep.status = drop.status;

            // Make sure reverse index points at the kept item
            try { originalIndex.set(on, keep.key); } catch (_) {}

            // Delete duplicate
            items.delete(drop.key);

            // Ensure map points at the kept one
            byOrig.set(on, keep.key);
          }
        } catch (_) {}

        const list = Array.from(items.values());
        const useAnalysisAction = isAnalysisHat();
        const actionLabel = useAnalysisAction ? "Analyze" : "Insert to chat";
        const actionName = useAnalysisAction ? "analyze" : "insert";

        menu.innerHTML = `
          <div class="uploadMenuHeader">
            <div class="uploadMenuHeaderTitle">Uploads</div>
            <button id="uploadMenuClear" class="uploadMiniBtn" type="button">Clear done</button>
          </div>
          ${list.length ? "" : `<div class="muted" style="padding:8px;">No recent uploads.</div>`}
          ${list.map(it => `
            <div class="uploadItem ${it.open ? "open" : ""}" data-key="${encodeURIComponent(it.key)}">

              <div class="uploadItemTop">
                <div style="min-width:0; flex:1;">
                  <div class="uploadItemName">${escapeHtml(it.originalName || it.key)}</div>
                  ${it.relPath ? `<div class="muted" style="font-size:11px; margin-top:2px;">${escapeHtml(it.relPath)}</div>` : ""}
                </div>
                <div class="uploadItemStatus">${escapeHtml(it.status)}</div>
              </div>
              <div class="uploadItemActions">
                <button class="uploadMiniBtn" data-action="toggle" type="button">${it.open ? "Hide" : "Details"}</button>
                <button class="uploadMiniBtn primary" data-action="${actionName}" type="button">${actionLabel}</button>
              </div>
              <div class="uploadDetail">${escapeHtml(it.detail || "")}</div>
            </div>
          `).join("")}
        `;

        const clearBtn = document.getElementById("uploadMenuClear");
        if (clearBtn) {
          clearBtn.onclick = () => {
            for (const [k, it] of items.entries()) {
              if (it.status === "done" || it.status === "error") items.delete(k);
            }
            unreadDone = 0;
            setBadge(0);
            render();
          };
        }

        // Delegate item buttons
        menu.querySelectorAll(".uploadItemActions button").forEach(btn => {
          btn.onclick = () => {
            const parent = btn.closest(".uploadItem");
            const keyEnc = parent?.getAttribute("data-key") || "";
            const key = keyEnc ? decodeURIComponent(keyEnc) : "";
            const it = items.get(key);
            const action = btn.getAttribute("data-action");
            if (!it) return;

            if (action === "toggle") {
              it.open = !it.open;
              render();
              return;
            }
            if (action === "insert") {
              // Insert into the composer (do NOT auto-send; do NOT append local assistant bubbles).
              // This ensures the filename/path is inserted exactly once.
              const header = (it.relPath ? it.relPath : (it.key || it.originalName || "")).trim();
              if (!header) return;

              try {
                const cur = (promptEl && typeof promptEl.value === "string") ? promptEl.value : "";
                const needsNL = cur && !cur.endsWith("\n");
                const next = cur + (needsNL ? "\n" : "") + header + "\n";
                if (promptEl) {
                  promptEl.value = next;
                  autoGrow(promptEl);
                  updateComposerChipState();
                  // Keep the user in control: focus so they can add context before sending.
                  try { promptEl.focus({ preventScroll: true }); } catch (_) { try { promptEl.focus(); } catch (_) {} }
                }
              } catch (_) {
                // If composer insertion fails for any reason, do nothing.
              }

              // mark as read-ish
              if (unreadDone > 0) {
                unreadDone = Math.max(0, unreadDone - 1);
                setBadge(unreadDone);
              }

              return;
            }
            if (action === "analyze") {
              // Manual re-run (analysis hat). Does not insert text into chat.
              requestSynthesis(it, { force: true });
              return;
            }

          };
        });
      }

      function openMenu() {

        if (!menu) return;
        menu.style.display = "";
        render();
        // If user opens, consider done messages "seen"
        unreadDone = 0;
        setBadge(0);
      }

      function closeMenu() {
        if (!menu) return;
        menu.style.display = "none";
      }

      function toggleMenu() {
        if (!menu) return;
        const open = menu.style.display !== "none";
        if (open) closeMenu();
        else openMenu();
      }

      function startBatch(n) {
        activeCount += Number(n || 0);
        setIndicatorActive(activeCount > 0);
      }

      function markUploaded(originalName, relativePath) {
        const saved = basename(relativePath);
        const it = ensureItem(saved, originalName);
        if (!it) return;
        it.relPath = String(relativePath || "");
        it.status = "uploading";
        render();
      }

      function consumeStatusFrame(frame) {
        const project = String(frame && frame.project ? frame.project : (currentProjectName || "default")).trim() || "default";
        const fileKey = String(frame && frame.file_key ? frame.file_key : "").trim();
        const status = String(frame && frame.status ? frame.status : "").trim().toLowerCase();
        const detail = String(frame && frame.detail ? frame.detail : "").trim();
        const relPath = String(frame && frame.relative_path ? frame.relative_path : "").trim();
        const batchId = String(frame && frame.batch_id ? frame.batch_id : "").trim();
        const analysisVer = String(frame && frame.analysis_version ? frame.analysis_version : "").trim();

        // Ignore frames for other projects
        if (project !== (currentProjectName || "default")) return;

        const key = resolveKeyFromName(fileKey || relPath || "");
        const it = ensureItem(key, fileKey || key);
        if (!it) return;

        if (relPath) it.relPath = relPath;
        if (batchId) it.batchId = batchId;
        if (analysisVer) it.analysisVersion = analysisVer;

        if (status === "queued") {
          it.status = "processing";
          it.detail = detail || it.detail || "";
          render();
          if (isAnalysisHat()) showThinking();
          return;
        }

        if (status === "done") {
          it.status = "done";
          it.detail = detail || it.detail || "";
          render();

          // Analysis hat: auto-synthesize on completion (skip ZIP batch files).
          if (isAnalysisHat() && !it.synthTriggered && !it.batchId) {
            it.synthTriggered = true;
            requestSynthesis(it, { force: false });
          }

          if (activeCount > 0) activeCount = Math.max(0, activeCount - 1);
          setIndicatorActive(activeCount > 0);

          unreadDone += 1;
          setBadge(unreadDone);
          return;
        }

        if (status === "error") {
          it.status = "error";
          it.detail = detail || it.detail || "";
          render();

          if (activeCount > 0) activeCount = Math.max(0, activeCount - 1);
          setIndicatorActive(activeCount > 0);

          unreadDone += 1;
          setBadge(unreadDone);
          return;
        }

        // Unknown status: store detail, keep current status
        if (detail) it.detail = detail;
        render();
      }


      function markError(originalName, msg) {
        const it = ensureItem(originalName, originalName);
        if (!it) return;
        it.status = "error";
        it.detail = msg;
        render();

        if (activeCount > 0) activeCount = Math.max(0, activeCount - 1);
        setIndicatorActive(activeCount > 0);

        unreadDone += 1;
        setBadge(unreadDone);
      }

      // NOTE: upload.status is now frame-based; no chat-text parsing.

      // Wire indicator clicks + outside click close
      if (indicator) {
        indicator.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          toggleMenu();
        };
      }
      document.addEventListener("click", (e) => {
        if (!menu || menu.style.display === "none") return;
        const t = e.target;
        if (t === indicator || menu.contains(t)) return;
        closeMenu();
      });

      return {
        startBatch,
        markUploaded,
        consumeStatusFrame,
        markError,
        refresh: render,
        requestSynthesis
      };
    })();
    window.UploadCenter = UploadCenter;

    // --- Batch progress bar (top bar) ---
    const BatchProgress = (() => {
      let track = document.getElementById("batchProgressTrack");
      let bar = document.getElementById("batchProgressBar");
      if (!track) {
        track = document.createElement("div");
        track.id = "batchProgressTrack";
        track.setAttribute("aria-hidden", "true");
        document.body.appendChild(track);
      }
      if (!bar) {
        bar = document.createElement("div");
        bar.id = "batchProgressBar";
        track.appendChild(bar);
      }

      let hideTimer = null;
      let indeterminateCount = 0;
      let determinateActive = false;

      function show() {
        if (!track) return;
        track.style.display = "block";
      }
      function hideSoon() {
        if (!track || !bar) return;
        try { if (hideTimer) clearTimeout(hideTimer); } catch (_) {}
        hideTimer = setTimeout(() => {
          if (determinateActive || indeterminateCount > 0) return;
          track.style.display = "none";
          track.classList.remove("indeterminate");
          bar.style.width = "0%";
        }, 900);
      }

      function startIndeterminate() {
        if (!track || !bar) return;
        indeterminateCount += 1;
        if (determinateActive) return;
        track.classList.add("indeterminate");
        show();
      }

      function stopIndeterminate() {
        if (!track || !bar) return;
        if (indeterminateCount > 0) indeterminateCount -= 1;
        if (indeterminateCount > 0) return;
        if (!determinateActive) hideSoon();
      }

      function isActive() {
        return determinateActive || indeterminateCount > 0;
      }

      function consumeFrame(frame) {
        if (!track || !bar) return;
        const project = String(frame && frame.project ? frame.project : (currentProjectName || "default")).trim() || "default";
        if (project !== (currentProjectName || "default")) return;

        const total = Number(frame && frame.total ? frame.total : 0);
        const done = Number(frame && frame.done ? frame.done : 0);
        const state = String(frame && frame.state ? frame.state : "progress").trim().toLowerCase();

        if (state === "finalizing") {
          determinateActive = false;
          track.classList.remove("indeterminate");
          track.classList.add("finalizing");
          show();
          bar.style.width = "100%";
          return;
        }

        if (!total || total <= 0) {
          if (!determinateActive) {
            track.classList.add("indeterminate");
            track.classList.remove("finalizing");
            show();
          }
          return;
        }

        determinateActive = true;
        track.classList.remove("indeterminate");
        track.classList.remove("finalizing");
        show();

        const pct = Math.max(2, Math.min(100, Math.round((done / total) * 100)));
        bar.style.width = pct + "%";

        if (state === "done" || done >= total) {
          bar.style.width = "100%";
          determinateActive = false;
          if (state === "done") {
            track.classList.remove("finalizing");
            if (indeterminateCount > 0) {
              track.classList.add("indeterminate");
              show();
            } else {
              hideSoon();
            }
          } else {
            // If we hit total but summary is still running, keep a visible pulse.
            track.classList.remove("indeterminate");
            track.classList.add("finalizing");
            show();
          }
        }
      }

      return { consumeFrame, startIndeterminate, stopIndeterminate, isActive };
    })();
    window.BatchProgress = BatchProgress;

    async function handleFiles(fileList) {
      const n = fileList ? fileList.length : 0;
      if (n > 0) UploadCenter.startBatch(n);

      // Upload sequentially (stable) but keep UI clean
      for (const file of fileList) {
        await uploadSingleFile(file);
      }
    }

    async function uploadSingleFile(file) {
      const formData = new FormData();
      formData.append("file", file);

      // No chat spam; just show progress in the top bar
      showThinking();

      try {
        const projectName = (currentProjectName || "").trim();
        const url = projectName
          ? `${BASE_UPLOAD_URL}?project=${encodeURIComponent(projectName)}`
          : BASE_UPLOAD_URL;

        const res = await fetch(url, { method: "POST", body: formData });

        if (!res.ok) {
          UploadCenter.markError(file.name, `[ERROR] Upload failed for ${file.name}: HTTP ${res.status}`);
          return;
        }

        const data = await res.json();
        if (!data.ok) {
          UploadCenter.markError(file.name, `[ERROR] Upload failed for ${file.name}: ${data.error || "unknown error"}`);
          return;
        }

        UploadCenter.markUploaded(file.name, data.relative_path);

        if (ws && ws.readyState === WebSocket.OPEN) {
          // Legacy: server still expects [FILE_ADDED] as a raw control message.
          ws.send(`[FILE_ADDED]${data.relative_path}`);
        }
      } catch (err) {
        UploadCenter.markError(
          file.name,
          `[ERROR] Upload failed for ${file.name}: ${err && err.message ? err.message : err}`
        );
      } finally {
        hideThinking();
      }
    }


    // Dark mode toggle
    function applyTheme(mode) {
      const root = document.documentElement;
      if (mode === "dark") {
        root.classList.add("dark");
        themeToggle.textContent = "Dark mode: On";
      } else {
        root.classList.remove("dark");
        themeToggle.textContent = "Dark mode: Off";
      }

      // Dark/light changes must re-apply the active expert palette
      try { applyExpertTheme(activeExpert || "default"); } catch (_) {}
    }

    function loadTheme() {
      const stored = window.localStorage.getItem("lens0-theme");
      if (stored === "dark" || stored === "light") {
        applyTheme(stored);
      } else {
        const hour = new Date().getHours();
        applyTheme(hour >= 18 || hour < 7 ? "dark" : "light");
      }
    }

    themeToggle.addEventListener("click", () => {
      const root = document.documentElement;
      const isDark = root.classList.contains("dark");
      const next = isDark ? "light" : "dark";
      applyTheme(next);
      window.localStorage.setItem("lens0-theme", next);
    });

    loadTheme();
    // Dedupe server greeting requests (prevents greeting churn on repeated thread.history)
    const __greetReqLastAt = Object.create(null); // project -> ts
    // Friendly companion greeting (debounced).
    // We schedule, not spam-call, so connect/restore/switch don't race each other.
    let __welcomeTimer = null;

    function scheduleWelcome(reason = "") {
      try {
        if (__welcomeTimer) clearTimeout(__welcomeTimer);
      } catch (_) {}

      __welcomeTimer = setTimeout(() => {
        __welcomeTimer = null;
        try { appendWelcomeMessage(); } catch (_) {}
      }, 180);
    }

    // Friendly companion greeting (ONE time per project per browser session).
    // This keeps startup human without spamming reconnects.
    function appendWelcomeMessage() {
      const u = (window.__LENS0_AUTH_USER || "guest").trim() || "guest";
      const p = (currentProjectName || desiredProjectName || "default").trim() || "default";

      // Only greet on NEW/EMPTY projects:
      // ? no goal yet (UI line is "Goal: (none yet)" / "Not set")
      // - no prior assistant chat stored for this project
      // - chat log is currently empty
      const goalText = (currentGoalLine && currentGoalLine.textContent) ? String(currentGoalLine.textContent) : "";
      const goal = goalText.replace(/^Goal:\s*/i, "").trim();
      const hasGoal =
        !!goal &&
        !goal.toLowerCase().includes("(none") &&
        !goal.toLowerCase().includes("not set");

      let hasPriorAssistant = false;
      try {
        const last = loadLastAssistantChat(p);
        hasPriorAssistant = !!(last && last.text && String(last.text).trim());
      } catch (_) {}

      // Only count REAL conversation bubbles (ignore status / system noise)
      let hasRealChat = false;
      try {
        if (logEl) {
          hasRealChat = !!logEl.querySelector(".chat-user, .chat-assistant");
        }
      } catch (_) {}

      if (hasGoal || hasPriorAssistant || hasRealChat) return;

      // Greet ONCE per project per browser session.
      const key = `lens0-welcome-shown:${u}:${p}`;
      try {
        if (window.sessionStorage.getItem(key) === "1") return;
        window.sessionStorage.setItem(key, "1");
      } catch (_) {
        // If sessionStorage fails, fall back to "best effort" (show once per page load)
      }

      function timeOfDayGreeting() {
        try {
          const hh = Number(
            new Intl.DateTimeFormat("en-US", {
              timeZone: "America/Chicago",
              hour12: false,
              hour: "2-digit"
            }).format(new Date())
          );
          if (isFinite(hh)) {
            if (hh >= 5 && hh < 12) return "Good morning";
            if (hh >= 12 && hh < 17) return "Good afternoon";
            return "Good evening";
          }
        } catch (_) {}
        return "Good day";
      }

      const lines = [];
      lines.push(`${timeOfDayGreeting()}. What can I help you with today-`);
      lines.push("You’re welcome to upload a file, or just tell me what you’re thinking and we can take it from there.");

      appendChat(lines.join("\n"), "assistant");
    }

    // Do not greet on raw page load (login/connect will schedule it).
    // Always open file artifacts in a new tab/page (mobile Safari reliability).
    // This protects against any anchor that accidentally lacks target="_blank".
    document.addEventListener("click", (e) => {
      const a = e.target && e.target.closest ? e.target.closest("a") : null;
      if (!a) return;

      const href = (a.getAttribute("href") || "").trim();
      if (!href) return;

      // Only intercept our served file route
      if (href.startsWith("/file-path=")) {
        e.preventDefault();
        try {
          window.open(href, "_blank", "noopener");
        } catch (_) {
          // Fallback: still navigate if popup blocked
          window.location.href = href;
        }
      }
    }, true);

    // On load: require login first (prevents unauthenticated reconnect loop)
    // Ensure all artifact/file links open in a new tab (prevents navigating away from the app).
    // Do NOT use window.open() (iOS Safari can block it); just enforce target=_blank.
    document.addEventListener("click", (e) => {
      const a = e.target && e.target.closest ? e.target.closest("a") : null;
      if (!a) return;

      const href = (a.getAttribute("href") || "").trim();
      if (!href) return;

      if (href.startsWith("/file-path=")) {
        if (!a.target) a.target = "_blank";
        if (!a.rel) a.rel = "noopener";
        // Let default navigation occur (in new tab).
      }
    }, true);

    showLogin("");  </script>
</body>
</html>
